## 알고리즘이란?

### 알고리즘의 정의와 조건

알고리즘은 **주어진 문제를 해결하기 위한 단계적인 절차**를 말합니다. 컴퓨터에서는 어떤 일을 하는 절차를 표현하기 위해 명령어들을 사용하는데, 결국 알고리즘은 특정한 일을 수행하는 명령어들의 집합으로 볼 수 있습니다. 이때 명령어(instrction set)란 컴퓨터에서 수행되는 문장들을 의미하는데, 이러한 문장들은 프로그래밍 언어의 종류나 스타일과는 관련이 없습니다. 즉, 알고리즘은 C언어나 Java, 파이썬 등과 같은 프로그래밍 언어와 상관없이 문제 해결 절차를 나타내는 명령어의 집합입니다.

그렇다고 프로그래밍을 위해 작성된 모든 명령어의 집합이 알고리즘이 되는 것은 아닙니다. 다음 조건들을 만족해야 합니다.

알고리즘 대부분은 입력을 요규하지만 때로는 입력이 필요 없는 경우(예를 들어, 난수 발생 알고리즘)도 있습니다. 그렇지만 반드시 하나 이상의 출력은 있어야 합니다. 의미가 모호한 명령어가 하나라도 포함된다면 알고리즘이 될 수 없으며, 컴퓨터가 실행할 수 없는 명령어(예를 들어, 0으로 나누는 연산)를 사용하면 역시 알고리즘이 아닙니다. 또한, 특정한 프로그래밍 언어에서만 의미가 있거나 무한히 반복되는 명령어들의 집합도 알고리즘이 아닙니다.

### 알고리즘의 기술 방법

알고리즘은 여러 가지 방법으로 기술할 수 있습니다. 

- 영어나 한국어와 같은 자연어를 사용하는 방법
- 흐름도(flowchart)로 표시하는 방법
- 특정한 프로그래밍 언어의 코드로 나타내는 방법
- 유사 코드(pseudo-code)로 기술하는 방법

간단한 문제로 예를 들어봅시다. 3개의 숫자 a, b, c가 주어졌을 때, 이들 중에서 가장 큰 값을 찾는 문제입니다.

먼저 최댓값을 저장할 변수를 하나 준비합니다. 이것을 max라 하겠습니다. 일단 a가 가장 큰 값이라고 생각하고, a를 max에 복사합니다. 다음으로 b를 max와 비교하여 b가 더 크면 max에 b를 복사하고, 이어서 c도 max와 비교하여 max를 출력합니다.

1. 자연어 표현 
    
    자연어를 사용하면 표현이 자유롭고 편리하다는 장점이 있지만, 자칫 문장의 의미가 애매해질 수 있습니다. 따라서 사용되는 단어들의 의미를 정확히 해야만 알고리즘이 될 수 있습니다.
    
    ```python
    find_max(a,b,c)
    	 a를 최댓값을 저장하는 변수 max에 복사합니다.
    	 만약 b가 max보다 크면 b를 max에 복사합니다.
       만약c가 max보다 크면 c를 max에 복사합니다.
       max를 반환합니다.
    ```
2. 흐름도 표현
    
    알고리즘의 절차를 가장 정확하게 표현할 수 있어서 특허 명세서 등에서 많이 사용됩니다. 그렇지만 알고리즘이 조금만 길어도 그림이 너무 복잡해져 혼란스러워진다는 문제가 있습니다.
    
3. 특정 프로그래밍 언어 표현
    
    프로그래밍 언어의 문법을 정확히 따라 기술해야 하는데, 언어의 특징에 따른 많은 불필요한 표현들이 알고리즘에 포함된다는 문제가 있습니다. 따라서 간단한 알고리즘도 매우 복잡해 보일 수 있고, 이것이 알고리즘의 핵심을 이해하는 것을 방해한다는 문제가 있습니다.
    
4. 유사코드 표현
    
    자연어보다는 체계적이지만 프로그래밍 언어보다는 덜 엄격한 방법입니다. 특히, 프로그래밍 언어에서 발생하는 많은 불필요한 표현을 생략할 수 있어 논문이나 도서들에서 흔히 사용됩니다.
    
    ```python
    find_max(a,b,c)
    	max <- a
    	if b > max then
    		max <- b
    	if c > max then
    		max <-
    	return max
    ```
    
5. 파이썬을 이용한 표현
    
    ```python
    def find_max(a,b,c):
    	max = a
    	if b > max:
    		max = b
    	if c > max:
    		max = c
    	return max
    ```
    

## 알고리즘의 성능 분석

어떤 문제를 해결할 수 있는 여러 알고리즘이 있을 때, 이들의 성능을 비교하기 위해 다양한 기준을 사용할 수 있습니다. 그중에서 가장 중요하게 사용되는 것은 연산량과 메모리 사용량입니다.

- 연산량: 알고리즘이 얼마나 적은 연산을 수행하는가?
- 메모리 사용량: 얼마나 적은 메모리 공간을 사용하는가?

연산량은 알고리즘이 수행해야 하는 작업(연산)의 양을 말하는데, 알고리즘의 **시간 효율성**을 나타냅니다. 메모리 사용량은 필요한 작업을 하는데 사용하는 기억 공간의 양을 말하는데, **공간 효율성**을 나타냅니다. 예전과 달리 요즘은 컴퓨터에 메모리가 풍부해졌기 때문에 공간 효율성의 중요성이 조금 떨어진 경향은 있지만, 여전히 성능 평가의 중요한 기준이 됩니다.

가장 좋은 알고리즘은 연산량과 메모리 사용량이 모두 작은 것이겠지만 이둘을 동시에 만족시키기는 쉽지 않습니다. 따라서 둘 중 하나를 골라야 한다면 보통은 시간 효율성을 선택합니다.

### 실행 시간 측정 방법

시간 효율성을 측정하는 단순하지만 가장 확실한 방법은 실행 시간을 직접 측정해 보는 것입니다. 어떤 알고리즘이 파이썬의 함수 `testAlgorithm()` 으로 구현되었다면 실행 시간은 다음과 같이 측정할 수 있스빈다.

```python
import time
start = time.time()
testAlgorithm(input)
...
end = time.time()
print("실행시간 = ", end-start)
```

이 방법은 치명적인 약점이 있습니다.

- 알고리즘을 반드시 구현해야 합니다. 알고리즘이 비교적 단순하다면 어렵지 않겠지만, 복잡한 경우에는 구현이 큰 부담이 될 수 있습니다.
- 여러 알고리즘의 측정 결과를 비교하기 위해서 반드시 같은 조건의 하드웨어를 사용해야 합니다.
- 프로그래밍 언어나 운영체제와 같은 소프트웨어 환경도 같아야 합니다. C나 C++과 같은 컴파일 방식 언어로 구현한 경우가 파이썬이나 베이직과 같이 명령어를 직접 실행하는 인터프리트 방식보다 훨씬 빠릅니다.
- 실험되지 않은 입력에 대해서는 실행시간을 주장할 수 없습니다.

### 복잡도 분석 방법

복잡도 분석(complexity analysis)는 구현하지 않고도 알고리즘의 시간 복잡도와 공간 복잡도를 구해 성능을 비교하는 방법입니다.

1부터 n까지의 합을 구하는 문제는 다음과 같이 해결할 수 있습니다.

```python
calc_sum1(n)
	sum <- 0
	for i <- i to n then
		sum <- sum + i
	return sum
```

그런데 다른 방법도 있습니다. 1부터 n까지의 합은 `n*(n+1)/2`을 이용해 바로 구할 수 있습니다.

 

```python
calc_sum2(n)
	sum <- n * (n+1) / 2
	return sum
```

두 가지 알고리즘 성능을 비교하기 위해선 얼마나 많은 연산이 실행되는지 계산해야 합니다. 보통 이러한 연산의 실행 횟수는 입력의 크기 n에 대한 함수 형태, 즉 T(n)으로 나타내는데, 이를 **복잡도 함수**라고 합니다.

- 알고리즘1: 2행에서 대입 연산(sum ← 0) 한번, 반복문 내부에서 4행(sum ← sum + i)은 n번 수행되는데, 대입과 덧셈 연산을 한번씩 수행합니다. 연산 실행 횟수를 모두 합하면 2n+1이 되고, 복잡도 함수는 `T(n) = 2n+1` 입니다.
- 알고리즘2:  모든 행이 한 번만 수행됩니다. 대입, 곱셈, 덧셈, 나눗셈 연산이 한 번씩 수행됩니다. 복잡도 함수는 `T(n) = 4`

알고리즘 2는 입력의 크기 n과 관계없이 같은 수의 연산이 실행됩니다. 이에 비해, 알고리즘 1은 입력의 크기 n에 비례하는 수의 연산이 실행됩니다.

### 복잡도의 점금적 표기

알고리즘의 복잡도는 흔히 더 간단한 형태로 단순화시켜 사용합니다. 알고리즘 1의 복잡도를 2n+1이라고 하지 않고, n이라 말하는 식입니다. 왜 이렇게 복잡도를 단순하게 나타내려고 할까요? 두 가지 알고리즘을 생각해 봅시다. n개의 숫자를 정렬하는 알고리즘 A와 알고리즘 B가 있고, 이들의 복잡도 함수가 각각 T(n) = 65536n + 200000와  T(n) = n**2 + 2n라고 가정해 보겠습니다.

그림과 같이 n이 10,000 이하일 때까지는 알고리즘 A가 더 많은 연산이 필요하므로 B가 효율적인 것처럼 보입니다. 그런데 n이 커질수록 연산 횟수의 역전이 일어나고, A와 B의 차이는 말할 수 없을 정도로 벌어지게 됩니다. 즉, n이 커질수록 큰 계수들의 영향이 점점 미미해지고, 최고차항 n**2을 제외한 나머지 항의 영향도 크게 줄어드는 것입니다. 만약 n이 무한대에 가까워지면 최고차항을 제외한 나머지 항의 효과는 거의 없는 것이나 마찬가지가 됩니다.

이러한 표현은 “정확히 몇 번의 연산이 필요한가?”가 아니라 “**연산량이 얼마나 빨리 증가하는가?**”만을 나타냅니다. 즉, 증가속도를 표현하는 것입니다.

1. 빅오(big-O) 표기법
    
    O(g(n))은 증가속도가 **g(n)과 같거나 낮은** 모든 복잡도 함수를 포함하는 집합니다. 어떤 알고리즘의  복잡도가 O(n**2)이라면 이 알고리즘은 어떤 경우에도 n**2에 비례하는 시간 안에는 반드시 완료된다는 것을 말합니다. 즉, n**2보다 더 빨리 처리 될 수는 있지만 절대로 그보다 더 걸릴 수는 없고, 이것은 처리시간의 상한(upper bound)을 의미합니다. 복잡도 함수가 2n + 1이면 이 알고리즘은 ‘O(n)에 속한다’ 또는 ‘O(n)이다’라고 말할 수 있습니다.
    
2. 빅오메가(big-omega) 표기법
    
    Ω(g(n))은 증가속도가 g(n)과 같거나 높은 모든 복잡도 함수를 포함합니다.
    
3. 빅세타(big-theta) 표기법
    
    Ø(g(n)은 증가속도가 g(n)과 같은 복잡도 함수들만 포함합니다.
    

일반적으로는 최악의 상황을 고려한 해결책을 찾기 때문에 빅오 표기법이 주로 사용됩니다.

### 최선, 최악, 평균적인 효율성

같은 알고리즘도 입력의 종류 또는 구성에 따라 다른 특성의 실행 시간을 보일 수 있습니다. 예를 들어, 보통의 경우 비효율적이라고 알려진 어떤 정렬 알고리즘은 거의 정렬이  되어 잇는 입력에 대해서는 다른 어떤 알고리즘보다 효율적으로 동작합니다. 알고리즘의 효율성은 입력의 특징에 따라 3가지 경우로 나누어 평가할 수 있습니다.

1. 최선의 경우(best case): 실행 시간이 가장 적은 경우를 말하는데, 알고리즘 분석에서는 큰 의미가 없습니다.
2. 평균적인 경우(average case): 알고리즘의 모든 입력을 고려하고 각 입력이 발생할 확률을 고려한 평균적인 실행시간을 의미하는데, 정확히 계산하기가 어렵습니다.
3. 최악의 경우(worst case): 입력의 구성이 알고리즘의 실행 시간을 가장 많이 요구하는 경우 말하는데, 가장 중요하게 사용됩니다.

**예: 리스트에서 어떤 값을 찾는 알고리즘**

```python
def find_key(A, key)
	n = len(A)
	for i in range(n):
		if A[i] == key:
			return i
	return -1
```

1. 최선의 경우: A의 첫 번째 요소가 key와 같은 경우가 최선 입니다. 즉, 4행은 한번만 처리되므로 복잡도 함수 T(n) = 1이고, O(1)입니다.
2. 최악의 경우: key가 리스트에 없거나 맨 뒤에 있는 경우가 최악의 입력입니다. 항상 모든 요소를 검사해야 하므로 n번의 비교가 필요하고, 따라서 복잡도 T(n) = n이고, O(n)입니다.
