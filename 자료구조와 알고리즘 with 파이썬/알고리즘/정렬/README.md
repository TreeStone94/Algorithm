## 정렬이란

정렬은 순서대로 나열하는 것을 말합니다. 정렬을 위해서는 서로 비교할 수 있는 값이 있어야 합니다. 

정렬 알고리즘들 선택할 때에는 효율성 외에도 중요한 특성들이 있습니다. 먼저 **안정성(stability)**은 입력 데이터 key값을 갖는 레코드가 여러개 있을 때, 정렬 후에도 이들의 상대적인 위치가 바뀌지 않는 것을 말합니다.


**제자리 정렬(in-place sorting)**은 입력 배열 이외에 추가적인 배열을 사용하지 않는 정렬을 말합니다. 효율성이 같다면 안정성을 갖고 제자리 정렬 특성이 있는 알고리즘이 더 우월합니다.

## 선택 정렬

**선택 정렬(selection sort)**은 리스트에서 가장 작은 숫자를 하나씩 찾아 순서대로 저장하는 것입니다.


위에 알고리즘은 단순하지만 한가지 문제가 있습니다. 정렬을 위해 입력 리스트 외에 추가적인 리스트가 필요한 것입니다. 최솟값이 선택되면 이 값을 출력 리스트에 저장하는 것이 아니라 입력 리스트의 첫 번째 요소와 교환하는 것으로 **제자리 정렬**로 개선할 수 있습니다.


```python
def selection_sort(A):
	n = len(A)
	for i in range(n-1):
		least = i
		for j in range(i+1, n):
			if(A[j] < A[least]):
				least = j
		# 파이썬에서 사용되는 두 변수 교환 방식
		A[i] , A[least] = A[least], A[i]
```


### 선택 정렬의 특징

- 알고리즘은 간단하지만, 시간 복잡도 ○(n²)으로 효율적이지 않습니다.
- 안정성을 만족하지도 않습니다.
- 제자리 정렬로 추가적인 리스트가 필요하지 않습니다.
- 자료의 구성에 상관없이 연산의 횟수가 결정된다는 장점이 있습니다. 이것은 정렬할 리스트의 크기가 정해지면 리스트에 어떤 숫자가 어떻게 들어가 있는지와 무관하게 정렬에 걸릴 시간을 예측할 수 잇는 것입니다.
- 리스트가 크기 않는 문제라면 충분히 사용할 수 있는 알고리즘입니다.

## 삽입 정렬

삽입 정렬은 정렬된 부분 리스트에 요소를 끼워 넣어 정렬하는 것을 말합니다.

```python
def insertion_sort(A):
	n = len(A)
	for i in range(1, n):
		key = A[i]
		j = i-1
		while j >= 0 and A[j] > key:
			A[j + 1] = A[j]
			j -= 1
		A[j + 1] = key
```

### 삽입 정렬의 특징

- 입력의 구성에 따라 처리시간이 달라지는데, 최악의 상황에 대한 시간 복잡도가 ○(n²)으로 효율적이지 않은 알고리즘입니다.
- 끼워 넣기를 위해 많은 레코드의 이동이 필요하므로 레코드의 크기가 큰 경우 선택 정렬보다도 효율적이지 않습니다.
- 제자리 정렬이고, 안정성도 충족합니다.(왜 안정성을 충족?)
- 레코드 대부분이 이미 정렬된 경우라면 효율적으로 사용될 수 있습니다.

## 퀵 정렬

기준을 두고 분할하여 정렬하는 방법을 말합니다.


```python
def quick_sort(A, left, right):
	if left < right:
		q = partition(A, left, right)
		quick_sort(A, left, q - 1)
		quick_sort(A, q + 1, right)
```

### 분할은 어떻게 할까?

분할의 아이디어는 탐색-교환 과정을 반복하는 것입니다.

탐색은 low를 오른쪽으로 hight를 왼쪽으로 진행하면서 조건에 맞지 않는 요소를 찾는 과정입니다.

- 왼쪽 부분 리스트: A[low]가 피벗 이하이면 왼쪽 부분 리스트에 적합하므로 low를 오른쪽으로 전진시키다가, A[low]가 피벗보다 클 때 멈춥니다.
- 오른쪽 부분 리스트: A[hight]가 피벗보다 크면 hight를 왼쪽으로 전진시키다가 [high]가 피벗보다 작으면 멈춥니다.
