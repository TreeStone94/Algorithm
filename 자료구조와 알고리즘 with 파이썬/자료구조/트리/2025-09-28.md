## 모스 코드 결정 트리

```python
table =[('A', '.-'),    ('B', '-...'),  ('C', '-.-.'),  ('D', '-..'),
        ('E', '.'),     ('F', '..-.'),  ('G', '--.'),   ('H', '....'),
        ('I', '..'),    ('J', '.---'),  ('K', '-.-'),   ('L', '.-..'),
        ('M', '--'),    ('N', '-.'),    ('O', '---'),   ('P', '.--.'),
        ('Q', '--.-'),  ('R', '.-.'),   ('S', '...'),   ('T', '-'),
        ('U', '..-'),   ('V', '...-'),  ('W', '.--'),   ('X', '-..-'),
        ('Y', '-.--'),  ('Z', '--..') ]

# 모스부호 인코딩
def encode(ch):
	idx = ord(ch) - ord('A')
	return table[idx][1]
	
# 모스부호 디코딩
def decode_simple(morse):
	for tp in table:
		if morse == tp[1]:
			return tp[0]
```

### 결정 트리

여러 단계의 복잡한 조건을 갖는 문제에 대해 조건과 그에 따른 해결방법을 트리 형태로 나타낸 것을 말합니다.

```python
# 코드 4.12: 모스코드 디코딩을 위한 결정트리 만들기
def make_morse_tree():
    root = TNode( None, None, None )
    for tp in table :
        code = tp[1]                    # 모스 코드
        node = root
        for c in code :                 # 맨 마지막 문자 이전까지 --> 이동
            if c == '.' :               # 왼쪽으로 이동
                if node.left == None :  # 비었으면 빈 노드 만들기
                    node.left = TNode (None, None, None)
                node = node.left        # 그쪽으로 이동
            elif c == '-' :             # 오른쪽으로 이동
                if node.right == None : # 비었으면 빈 노드 만들기
                    node.right = TNode (None, None, None)
                node = node.right     # 그쪽으로 이동

        node.data = tp[0]               # 코드의 알파벳
    return root

# 코드 4.13: 결정트리를 이용한 디코딩 함수
def decode(root, code):
    node = root
    for c in code :                 # 맨 마지막 문자 이전까지 --> 이동
        if c == '.' :               # 왼쪽으로 이동
            node = node.left
        elif c=='-' :
           node = node.right
    return node.data
```

## 수식 트리

산술시을 트리 형태로 표현한 이진 트리입니다. 수식 트리의 계산에는 후위순회가 사용됩니다. 자식을 먼저 처리해야 부모 노드을 처리할 수 있기 때문입니다.

```python
def evaluate(node) :
    if node is None :
       return 0
    elif node.isLeaf() :
       return node.data
    else :
        op1 = evaluate(node.left)
        op2 = evaluate(node.right)
        if node.data == '+' : return op1 + op2
        elif node.data == '-' : return op1 - op2
        elif node.data == '*' : return op1 * op2
        elif node.data == '/' : return op1 / op2
```

컴퓨터는 중위표기는 여러 가지 불편한 점이 많습니다. 일단 중위 표기에는 괄호가 사용되는데 처리가 번거롭습니다. 또한, 연산자들에 우선순위가 있어 이를 처리해야 합니다. 후위표기는 이러한 번거로운 문제들을 피할 수 있습니다.

```python
from BinaryTree import *
def buildETree( expr ):
    if len(expr) == 0 :                 
        return None

    token = expr.pop()                  
    if token in "+-*/" :                
        node = BTNode(token)            
        node.right= buildETree(expr)    
        node.left = buildETree(expr)    
        return node
    else :                              
        return BTNode(float(token)) 
```
