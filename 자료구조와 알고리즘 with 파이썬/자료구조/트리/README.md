## 트리란?

트리 구조는 계층적인 관계를 가진 자료의 표현에 매우 유용하게 사용됩니다. 예를 들어, 회사의 조직 처계를 표현해봅시다. 회사의 사장은 나무의 뿌리에 해당합니다.


이러한 구조를 트리라고 부르는 것은 이들이 마치 실제 나무를 거꾸로 엎어높은 것과 비슷한 모양을 하고 있기 때문입니다. 지금까지 공부한 선형 자료구조들과 마찬가지로 트리는 매우 다양하게 활용됩니다. 운영체제에서 파일 시스템이 트리 구조로 이루어져 있고, 효율적인 탐색을 위해서도 트리가 사용됩니다. 우선순위 큐를 효율적으로 구현하기 위해 트리가 사용되고, 의사 결정 구조를 표현하기 위한 중요한 방법으로 결정 트리(decision tree)가 사용됩니다.

### 트리 관련 용어

트리에서 각각의 요소들을 **노드(node)**라고 부르는데, 트리는 하나 이상의 노드들로 이루어집니다. 위에 그림의 조직도에서 각각의 박스들이 노드에 해당합니다. 노드와 노드의 연결 관계는 **간선** 또는 **에지(edge)**로 나타냅니다. 조직도에서 ‘사장’과 같이 계층적인 구조에서 가장 높은 곳에 있는 노드를 **루트 노드(root node)**라고 부릅니다.



트리의 모든 노드는 자신을 루트로 하는 하나의 서브 트리를 대표합니다. 예를 들어, 루트 노드 A와 세 개의 서브 트리로 이루어지는데, 서브 트리들은 다시 각각 B, C, D를 루트로 갖는 트리입니다. 따라서 트리는 순환적으로 정의되는 자료구조라고 볼 수 있고, 순환호출을 사용하는 순환 알고리즘이 흔히 사용됩니다.

### 트리 표현 방법

1. 중첩된 집합
    
    트리가 서브 트리들의 집합이라는 것을 잘 나타낼 수 있습니다.
    
    
2. 중첩된 괄호
    
    다음 그림과 같이 이 방법은 트리를 하나의 문자열처럼 표현할 수 있다는 장점이 있습니다. 그러나 이것만으로 트리의 구조를 직관적으로 이해하기에는 다소 어려움이 있습니다.
    
    
3. 들여쓰기
    
    자료가 계층적인 구조를 갖는 것을 잘 나타내는데, 윈도우 탐색기에서 폴더와 파일을 나타내기 위해 흔히 사용됩니다.
    
    

### 일반 트리의 표현

자식의 개수에 제한이 없는 트리를 일반 트리(general tree)라고 부릅니다. 이런 트리를 프로그램에서 표현하는 데는 두가지 방법이 있습니다.

1. N-링크 표현
    
    가장 간단한 방법은 차수가 N인 노드가 N개의 링크를 갖도록 허용하는 것입니다. 이 경우 각 노드는 하나의 데이터 필드와 자식 노드 개수만큼의 링크를 갖습니다. 
    
    
    노드 A는 세 개의 자식이 있으므로 링크가 셋이고, D는 두개의 링크를 갖습니다. C, E, F, G와 같은 단말 노드는 링크가 하나도 없습니다. 이 방법은 간단해 보이긴 하지만 **노드마다 링크의 개수가 다르다는 문제**가 있습니다. 예를 들어, 컴퓨터 폴더 구조를 트리로 나타내는 경우, 하나의 폴더에 파일이나 폴더가 하나도 없을 수도 있고 수 천개일 수도 있는 것입니다. 이를 위해, 노드별로 링크를 관리하기 위해 연결 리스트를 사용할 수 있지만, 트리의 표현과 관리가 복잡해질 수 밖에 없습니다.
    
2. 왼쪽 자식-오른쪽 형제 표현
    
    노드의 형태를 좀더 단순화하는 방법도 있습니다. 노드 N개가 아니라 두개의 링크만 갖도록 하는 방법입니다. 링크의 용도를 정해서 이 문제를 해결할 수 있습니다. 하나의 링크는 왼쪽 자식(첫 번째 자식, child)을 가리키고, 다른 하나는 오른쪽 형제(다음형제, sibling)를 가리키기 위해 사용하는 것입니다.


## 이진 트리

이진 트리(binary tree)는 모든 노드가 최대 2개의 자식만 가질 수 있는 트리입니다.즉, 모든 노드의 차수가 2 이하로 제한된 트리입니다. 이때 자식 사이에도 순서가 존재하는데, 왼쪽 자식과 오른쪽 자식은 반드시 구별되어야 합니다.

이 트리는 무제한의 자식을 허용하는 일반 트리에 비해 계층적인 관계를 가진 모든 자료를 표현하기 부족합니다. 그러나 이러한 특별한 구조를 이용해 여러 훌륭한 알고리즘들이 개발되었습니다. 아주 빠른 자료의 탐색이 가능한 이진 탐색 트리(binary search tree), 우선순위 큐를 효과적으로 구현하는 힙 트리(heap tree), 수식을 트리형태로 표한하여 계산하는 수신 트리(expression tree) 등이 모두 이진 트리의 대표적인 예입니다.

### 이진 트리의 종류

이진 트리는 레벨과 노드 수의 관계에 따라 포화 이진 트리와 완전 이진 트리를 정의할 수 있습니다. 또한, 서브 트리의 높이에 균현의 개념을 적용하면 균형 이진 트리를 정의 할 수 있습니다. 


1. 포화 이진 트리(full binary tree)
    
    트리의 각 레벨에 노드가 꽉 차있는 이진 트리를 말합니다.
    
    
    노드가 꽉 차 있으니까 트리의 높이를 알면 전체 노드의 수를 쉽게 계산할 수 있습니다.
    
    
    포화 이진 트리는 각 노드에 순서대로 번호를 붙일 수 있습니다. 위에서 아래로 내려오면서 왼쪽에서 오른쪽으로 순서대로 번호를 붙이면 되는데, 이 번호는 항상 일정합니다.
    
2. 완전 이진 트리(complete binary tree)
    
    높이가 k인 트리에서 레벨 1부터 k-1까지는 노드가 모두 채워져있고 마지막 레벨k에서는 왼쪼부터 오른쪽으로 노드가 순서대로 채워져 있는 이진 트리를 말합니다.
    
    마지막 레벨에서는 노드가 꽉 차 있지 않아도 되지만 중간에 빈 곳이 있으면 안됩니다. 따라서 포화 이진 트리는 완전 이진 트리이지만 그 역은 항상 성립하지 않습니다. 힙(heap)은 완전 이진 트리의 대표적인 예입니다.
    
    
3. 균형 이진 트리(balanced binary tree)
    
    좌우 서브 트리를 구분하기 때문에 규현의 개념을 적용할 수 있습니다. 균현 이진 트리 또는 높이균현 이진 트리(height-balanced binary tree)는 모든 노드에서 좌우 서브 트리의 높이 차이가 1 이하인 트리를 말합니다.
    
    

### 이진 트리의 표현 방법

1. 배열 구조 표현
    
    이진 트리를 포화 이진 트리의 일부라고 생각하면 배열 구조로 트리를 표현할 수 있습니다. 포화 이진 트리에서 노드에 번호를 붙이는 것을 그대로 배열의 인덱스로 사용하는 것입니다.
    
    보통 루트 노드의 번호를 1로 하는데, 계산의 편의를 위해 인덱스 0은 사용하지 않겠습니다. (b)와 같은 심한 경사 트리의 경우 배열 항목 사이에 사용하지 않는 빈칸이 많이 발생하여 메모리의 낭비가 심해질 수 있습니다.
    
    
    이 표현법에서는 어떤 노드의 인덱스를 알면 부모 노드나 자식 노드의 인덱스를 손쉽게 계산할 수 있습니다.
    
    - 노드 i의 부모 노드 인덱스 = i/2
    - 노드 i의 왼쪽 자식 노드 인덱스 = 2*i
    - 노드 i의 오른쪽 자식 노드 인덱스 = 2*i + 1
2. 연결된 구조 표현: 링크 표현법
    
    연결된 구조로도 이진 트리를 나타낼 수 있습니다. 이진 트리를 위한 노드는 두 개의 링크가 필요한데, 이들은 각각 왼쪽(left)과 오른쪽(right) 자식 노드를 가리킵니다. 이 때 좌우 링크는 반드시 구별되어야 합니다. 
    
    
    부모와 자식의 관계를 나타내기 위해서는 간선을 화살표로 나타내는 것이 더 정확하지만, 화살표가 없이 연결된 경우에는 위쪽이 부모 노드, 아래쪽이 자식 노드입니다.
    
    
    이진 트리를 위한 노드 클래스를 BTNode라고 하면, 다음과 같이 표현 할 수 있습니다.
    
    ```python
    class BTNode:
    	def __init__ (self, elem, left=None, right=None):
    		self.data = elem
    		self.left = left
    		self.right = right
    ```
    

## 이진 트리의 연산

이진 트리는 루트와 두개의 서브 트리로 이루어지는데, 서브 트리도 모두 이진 트리여야 한다는 순환적인 조건이 있습니다. 이러한 순환적인 특징에 의해 이진 트리의 연산에는 순환 알고리즘이 흔히 사용됩니다.

### 이진 트리의 표준 순회

트리를 순회(traversql)한다는 것은 트리의 **모든 노드를 한 번씩 방문**하는 것을 말합니다. 예를 들어, 트리의 모든 노드를 한 번씩 화면에 출력하기 위해서도 순회가 필요한데, 순회는 모든 자료구조에서 기본적인 연산의 하나입니다.

일단, 선형 자료구조에서는 항목을 일렬로 저장되어 있어서 순회가 매우단순합니다. 순서대로 방문하면 되기 때문입니다. 그렇지만 트리에서는 자료가 일렬로 나열되어 있지 않기 때문에 여러 가지 ‘순서’로 노드를 방문할 수 있고, 따라서 순회 방법이 다양합니다.


기본적인 순회 방법은 전위, 중위, 후위로 나눌 수 있는데, 이를 이진 트리의 표준순회라고 합니다. 이들은 루트와 왼쪽 서브 트리, 오른쪽 서브 트리를 각각 어떤 순서로 방문하느냐에 따라 구분 됩니다. 루트를 방문하는 작업을 V, 왼쪽과 오른쪽 서브 트리를 방문하는 작업을 각각 L과 R이라 하면, 이들을 처리하는 순서에 따라 다음과 같이 세가지로 나눌 수 있습니다.

- 전위순회(preorder traversal): VLR
- 중위순회(inorder traversal): LVR
- 후위순회(postorder traversal): LRV


트리에서는 전체 트리나 서브 트리나 기본 구조가 완전히 같으므로 전체 트리에 사용된 알고리즘은 똑같이 서브 트리에도 적용할 수 있습니다. 따라서 순환 기법(재귀 호출)이 흔히 사용됩니다. 물론 순환이 진행됨에 따라 문제의 크키는 작아집니다.

1. 전위순회
    
    루트(V)를 먼저 방문하고 다음에 왼쪽 서브 트리(L) 방문하고, 방문이 끝나면 마지막으로 오른쪽 서브 트리를 방문(R)하는 방식입니다.
    
    
    ```python
    	def preorder(n):
    		if n is not None:
    			print(n.data, end=' ')
    			preorder(n.left)
    			preorder(n.right)
    ```
    
2. 중위순회
    
    왼쪽 서브 트리(L) 시작해서 오른쪽 서브 트리(R)로 방문합니다. 
    
    
    루트인 A를 처리하기 전에 왼쪽 서브 트리를 먼저 처리해야합니다. 왼쪽 서브 트리는 다시 루트인 B를 처리하기 전에 다시 왼쪽으로 내려가야 합니다. 결국 D가 먼저 처리됩니다. B의 왼쪽 서브 트리가 처리되었으므로 이제 B를 처리하고, 다음으로 E를 처리합니다.
    
    ```python
    	def inorder(n):
    		if n is not None:
    			inorder(n.left)
    			print(n.data, end=' ')
    			inorder(n.right)
    ```
    
3. 후위순회
    
    왼쪽 서브 트리(L) → 오른쪽 서브 트리(R) → 루트(V)순으로 방문합니다.
    
    
    ```python
    	def postorder(n):
    		postorder(n.left)
    		postorder(n.right)
    		print(n.data, end= ' ')
    ```
    

**순회 방법의 선택**

트리와 관련된 문제 중에는 순회 알고리즘만 잘 이용해도 해결되는 것들이 많습니다. 그렇다면 순회 방법은 어떻게 선택할까요?

- 순서는 중요하지 않고 노드를 전부 방문하기만 하면 된다면 어떤 방법도 상관이 없습니다. 예를 들어, 모든 노드 값을 순서와 상관없이 출력하면 되는 문제에서는 순회 방법이 중요하지 않습니다.
- 자식을 먼저 처리해야 부모를 처리할 수 있다면 당연히 후위순회를 사용해야 합니다. 예를 들어, 컴퓨터에서 어떤 폴더의 용량은 하위폴더들의 용량을 알아야만 계산할 수 있습니다. 따라서 후위순회를 사용해야합니다.
- 부모가 처리되어야 자식을 처리할 수 있다면 전위순회를 사용해야 합니다. 예를 들어, 모든 노드에서 자신의 레벨을 계산하는 경우 전위순회를 사용해야 합니다. 루트의 레벨이 1이고 나머지 모든 노드는 부모의 레벨보다 1이 크기 때문에, 부모의 레벨이 결정되어야 자식의 레벨을 결정할 수 있스빈다.

### 레벨 순회

레벨 순회는 레벨 순으로 노드를 방문합니다. 루트의 레벨이 1이고 아래로 내려갈수록 레벨이이 증가 하므로 위에서 아래로 방문하고, 같은 레벨에서는 왼쪽에서 오른쪽으로 방문합니다.


이러한 순서는 어떻게 구현할 수 있을까요? 큐를 이용하면 간단하게 해결할 수 있습니다. 큐에 노드를 넣고 빼는 과정을 반복하는 것입니다. 맨 처음에는 공백 상태의 큐에 루트를 넣습니다. 다음부터는 큐에서 노드 하나를 꺼내 방문하고 그 노드의 자식들을 큐에 삽입하는 과정을 반복합니다. 삽입에도 순서가 있는데, 왼쪽 자식을 먼저 넣고 오른쪽 자식을 다음에 넣습니다. 물론 자식이 없으면 삽입하지 않습니다. 이 과정은 큐가 공백 상태가 될 때 까지 반복됩니다.


```python
	def levelorder(root):
		queue = ArrayQueue()
		queue.enqueue(root)
		while not queue.isEmpty():
			n = queue.dequeue()
			if n is not None:
				print(n.data, end=' ')
				queue.enqueue(n.left)
				queue.enqueue(n.right)
```

### 이진 트리의 연산들

1. 전체 노드의 수 구하기
    
    이진 트리에서 어떤 문제를 해결하기 위해서는 일단 순환을 떠올려보는 것이 좋습니다.
    
    
    ```python
    	def count_node(n):
    		if n is None:
    			return 0
    		else:
    			return count_node(n.left) + count_node(n.right) + 1
    ```
    
2. 트리의 높이 구하기
    
    
    ```python
    	def calc_height(n):
    		if n is None:
    			return 0
    		hLeft = calc_height(n.left)
    		hRight = calc_height(n.right)
    		if (hLeft > hRight):
    			return hLeft + 1
    		else: return hRight + 1
    ```

    
    이 방법은 비교적 단순한 형태의 노드를 이용해 임의의 일반 트리를 표현할 수 있습니다. 그러나 표현이 복잡하고 특히 루트인 A에서 G까지 찾아가는 과정에서 필요 없이 많은 노드를 거쳐야 하는 문제가 있습니다.

## 모스 코드 결정 트리

```python
table =[('A', '.-'),    ('B', '-...'),  ('C', '-.-.'),  ('D', '-..'),
        ('E', '.'),     ('F', '..-.'),  ('G', '--.'),   ('H', '....'),
        ('I', '..'),    ('J', '.---'),  ('K', '-.-'),   ('L', '.-..'),
        ('M', '--'),    ('N', '-.'),    ('O', '---'),   ('P', '.--.'),
        ('Q', '--.-'),  ('R', '.-.'),   ('S', '...'),   ('T', '-'),
        ('U', '..-'),   ('V', '...-'),  ('W', '.--'),   ('X', '-..-'),
        ('Y', '-.--'),  ('Z', '--..') ]

# 모스부호 인코딩
def encode(ch):
	idx = ord(ch) - ord('A')
	return table[idx][1]
	
# 모스부호 디코딩
def decode_simple(morse):
	for tp in table:
		if morse == tp[1]:
			return tp[0]
```

### 결정 트리

여러 단계의 복잡한 조건을 갖는 문제에 대해 조건과 그에 따른 해결방법을 트리 형태로 나타낸 것을 말합니다.

```python
# 코드 4.12: 모스코드 디코딩을 위한 결정트리 만들기
def make_morse_tree():
    root = TNode( None, None, None )
    for tp in table :
        code = tp[1]                    # 모스 코드
        node = root
        for c in code :                 # 맨 마지막 문자 이전까지 --> 이동
            if c == '.' :               # 왼쪽으로 이동
                if node.left == None :  # 비었으면 빈 노드 만들기
                    node.left = TNode (None, None, None)
                node = node.left        # 그쪽으로 이동
            elif c == '-' :             # 오른쪽으로 이동
                if node.right == None : # 비었으면 빈 노드 만들기
                    node.right = TNode (None, None, None)
                node = node.right     # 그쪽으로 이동

        node.data = tp[0]               # 코드의 알파벳
    return root

# 코드 4.13: 결정트리를 이용한 디코딩 함수
def decode(root, code):
    node = root
    for c in code :                 # 맨 마지막 문자 이전까지 --> 이동
        if c == '.' :               # 왼쪽으로 이동
            node = node.left
        elif c=='-' :
           node = node.right
    return node.data
```

## 수식 트리

산술시을 트리 형태로 표현한 이진 트리입니다. 수식 트리의 계산에는 후위순회가 사용됩니다. 자식을 먼저 처리해야 부모 노드을 처리할 수 있기 때문입니다.

```python
def evaluate(node) :
    if node is None :
       return 0
    elif node.isLeaf() :
       return node.data
    else :
        op1 = evaluate(node.left)
        op2 = evaluate(node.right)
        if node.data == '+' : return op1 + op2
        elif node.data == '-' : return op1 - op2
        elif node.data == '*' : return op1 * op2
        elif node.data == '/' : return op1 / op2
```

컴퓨터는 중위표기는 여러 가지 불편한 점이 많습니다. 일단 중위 표기에는 괄호가 사용되는데 처리가 번거롭습니다. 또한, 연산자들에 우선순위가 있어 이를 처리해야 합니다. 후위표기는 이러한 번거로운 문제들을 피할 수 있습니다.

```python
from BinaryTree import *
def buildETree( expr ):
    if len(expr) == 0 :                 
        return None

    token = expr.pop()                  
    if token in "+-*/" :                
        node = BTNode(token)            
        node.right= buildETree(expr)    
        node.left = buildETree(expr)    
        return node
    else :                              
        return BTNode(float(token)) 
```
    
    다행히 실제로는 좀 더 단순한 형태의 트리를 많이 사용하는데, 아이디어는 트리 노드의 자식 수에 제한을 두는 것입니다. 예를 들어, 자식 최대 2개, 또는 최대 3개만을 가질 수 있도록 제한한 트리를 이용하는 것입니다.
