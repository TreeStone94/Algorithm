## 이진 트리

이진 트리(binary tree)는 모든 노드가 최대 2개의 자식만 가질 수 있는 트리입니다.즉, 모든 노드의 차수가 2 이하로 제한된 트리입니다. 이때 자식 사이에도 순서가 존재하는데, 왼쪽 자식과 오른쪽 자식은 반드시 구별되어야 합니다.

이 트리는 무제한의 자식을 허용하는 일반 트리에 비해 계층적인 관계를 가진 모든 자료를 표현하기 부족합니다. 그러나 이러한 특별한 구조를 이용해 여러 훌륭한 알고리즘들이 개발되었습니다. 아주 빠른 자료의 탐색이 가능한 이진 탐색 트리(binary search tree), 우선순위 큐를 효과적으로 구현하는 힙 트리(heap tree), 수식을 트리형태로 표한하여 계산하는 수신 트리(expression tree) 등이 모두 이진 트리의 대표적인 예입니다.

### 이진 트리의 종류

이진 트리는 레벨과 노드 수의 관계에 따라 포화 이진 트리와 완전 이진 트리를 정의할 수 있습니다. 또한, 서브 트리의 높이에 균현의 개념을 적용하면 균형 이진 트리를 정의 할 수 있습니다. 


1. 포화 이진 트리(full binary tree)
    
    트리의 각 레벨에 노드가 꽉 차있는 이진 트리를 말합니다.
    
    
    노드가 꽉 차 있으니까 트리의 높이를 알면 전체 노드의 수를 쉽게 계산할 수 있습니다.
    
    
    포화 이진 트리는 각 노드에 순서대로 번호를 붙일 수 있습니다. 위에서 아래로 내려오면서 왼쪽에서 오른쪽으로 순서대로 번호를 붙이면 되는데, 이 번호는 항상 일정합니다.
    
2. 완전 이진 트리(complete binary tree)
    
    높이가 k인 트리에서 레벨 1부터 k-1까지는 노드가 모두 채워져있고 마지막 레벨k에서는 왼쪼부터 오른쪽으로 노드가 순서대로 채워져 있는 이진 트리를 말합니다.
    
    마지막 레벨에서는 노드가 꽉 차 있지 않아도 되지만 중간에 빈 곳이 있으면 안됩니다. 따라서 포화 이진 트리는 완전 이진 트리이지만 그 역은 항상 성립하지 않습니다. 힙(heap)은 완전 이진 트리의 대표적인 예입니다.
    
    
3. 균형 이진 트리(balanced binary tree)
    
    좌우 서브 트리를 구분하기 때문에 규현의 개념을 적용할 수 있습니다. 균현 이진 트리 또는 높이균현 이진 트리(height-balanced binary tree)는 모든 노드에서 좌우 서브 트리의 높이 차이가 1 이하인 트리를 말합니다.
    
    

### 이진 트리의 표현 방법

1. 배열 구조 표현
    
    이진 트리를 포화 이진 트리의 일부라고 생각하면 배열 구조로 트리를 표현할 수 있습니다. 포화 이진 트리에서 노드에 번호를 붙이는 것을 그대로 배열의 인덱스로 사용하는 것입니다.
    
    보통 루트 노드의 번호를 1로 하는데, 계산의 편의를 위해 인덱스 0은 사용하지 않겠습니다. (b)와 같은 심한 경사 트리의 경우 배열 항목 사이에 사용하지 않는 빈칸이 많이 발생하여 메모리의 낭비가 심해질 수 있습니다.
    
    
    이 표현법에서는 어떤 노드의 인덱스를 알면 부모 노드나 자식 노드의 인덱스를 손쉽게 계산할 수 있습니다.
    
    - 노드 i의 부모 노드 인덱스 = i/2
    - 노드 i의 왼쪽 자식 노드 인덱스 = 2*i
    - 노드 i의 오른쪽 자식 노드 인덱스 = 2*i + 1
2. 연결된 구조 표현: 링크 표현법
    
    연결된 구조로도 이진 트리를 나타낼 수 있습니다. 이진 트리를 위한 노드는 두 개의 링크가 필요한데, 이들은 각각 왼쪽(left)과 오른쪽(right) 자식 노드를 가리킵니다. 이 때 좌우 링크는 반드시 구별되어야 합니다. 
    
    
    부모와 자식의 관계를 나타내기 위해서는 간선을 화살표로 나타내는 것이 더 정확하지만, 화살표가 없이 연결된 경우에는 위쪽이 부모 노드, 아래쪽이 자식 노드입니다.
    
    
    이진 트리를 위한 노드 클래스를 BTNode라고 하면, 다음과 같이 표현 할 수 있습니다.
    
    ```python
    class BTNode:
    	def __init__ (self, elem, left=None, right=None):
    		self.data = elem
    		self.left = left
    		self.right = right
    ```
    

## 이진 트리의 연산

이진 트리는 루트와 두개의 서브 트리로 이루어지는데, 서브 트리도 모두 이진 트리여야 한다는 순환적인 조건이 있습니다. 이러한 순환적인 특징에 의해 이진 트리의 연산에는 순환 알고리즘이 흔히 사용됩니다.

### 이진 트리의 표준 순회

트리를 순회(traversql)한다는 것은 트리의 **모든 노드를 한 번씩 방문**하는 것을 말합니다. 예를 들어, 트리의 모든 노드를 한 번씩 화면에 출력하기 위해서도 순회가 필요한데, 순회는 모든 자료구조에서 기본적인 연산의 하나입니다.

일단, 선형 자료구조에서는 항목을 일렬로 저장되어 있어서 순회가 매우단순합니다. 순서대로 방문하면 되기 때문입니다. 그렇지만 트리에서는 자료가 일렬로 나열되어 있지 않기 때문에 여러 가지 ‘순서’로 노드를 방문할 수 있고, 따라서 순회 방법이 다양합니다.


기본적인 순회 방법은 전위, 중위, 후위로 나눌 수 있는데, 이를 이진 트리의 표준순회라고 합니다. 이들은 루트와 왼쪽 서브 트리, 오른쪽 서브 트리를 각각 어떤 순서로 방문하느냐에 따라 구분 됩니다. 루트를 방문하는 작업을 V, 왼쪽과 오른쪽 서브 트리를 방문하는 작업을 각각 L과 R이라 하면, 이들을 처리하는 순서에 따라 다음과 같이 세가지로 나눌 수 있습니다.

- 전위순회(preorder traversal): VLR
- 중위순회(inorder traversal): LVR
- 후위순회(postorder traversal): LRV


트리에서는 전체 트리나 서브 트리나 기본 구조가 완전히 같으므로 전체 트리에 사용된 알고리즘은 똑같이 서브 트리에도 적용할 수 있습니다. 따라서 순환 기법(재귀 호출)이 흔히 사용됩니다. 물론 순환이 진행됨에 따라 문제의 크키는 작아집니다.

1. 전위순회
    
    루트(V)를 먼저 방문하고 다음에 왼쪽 서브 트리(L) 방문하고, 방문이 끝나면 마지막으로 오른쪽 서브 트리를 방문(R)하는 방식입니다.
    
    
    ```python
    	def preorder(n):
    		if n is not None:
    			print(n.data, end=' ')
    			preorder(n.left)
    			preorder(n.right)
    ```
    
2. 중위순회
    
    왼쪽 서브 트리(L) 시작해서 오른쪽 서브 트리(R)로 방문합니다. 
    
    
    루트인 A를 처리하기 전에 왼쪽 서브 트리를 먼저 처리해야합니다. 왼쪽 서브 트리는 다시 루트인 B를 처리하기 전에 다시 왼쪽으로 내려가야 합니다. 결국 D가 먼저 처리됩니다. B의 왼쪽 서브 트리가 처리되었으므로 이제 B를 처리하고, 다음으로 E를 처리합니다.
    
    ```python
    	def inorder(n):
    		if n is not None:
    			inorder(n.left)
    			print(n.data, end=' ')
    			inorder(n.right)
    ```
    
3. 후위순회
    
    왼쪽 서브 트리(L) → 오른쪽 서브 트리(R) → 루트(V)순으로 방문합니다.
    
    
    ```python
    	def postorder(n):
    		postorder(n.left)
    		postorder(n.right)
    		print(n.data, end= ' ')
    ```
    

**순회 방법의 선택**

트리와 관련된 문제 중에는 순회 알고리즘만 잘 이용해도 해결되는 것들이 많습니다. 그렇다면 순회 방법은 어떻게 선택할까요?

- 순서는 중요하지 않고 노드를 전부 방문하기만 하면 된다면 어떤 방법도 상관이 없습니다. 예를 들어, 모든 노드 값을 순서와 상관없이 출력하면 되는 문제에서는 순회 방법이 중요하지 않습니다.
- 자식을 먼저 처리해야 부모를 처리할 수 있다면 당연히 후위순회를 사용해야 합니다. 예를 들어, 컴퓨터에서 어떤 폴더의 용량은 하위폴더들의 용량을 알아야만 계산할 수 있습니다. 따라서 후위순회를 사용해야합니다.
- 부모가 처리되어야 자식을 처리할 수 있다면 전위순회를 사용해야 합니다. 예를 들어, 모든 노드에서 자신의 레벨을 계산하는 경우 전위순회를 사용해야 합니다. 루트의 레벨이 1이고 나머지 모든 노드는 부모의 레벨보다 1이 크기 때문에, 부모의 레벨이 결정되어야 자식의 레벨을 결정할 수 있스빈다.

### 레벨 순회

레벨 순회는 레벨 순으로 노드를 방문합니다. 루트의 레벨이 1이고 아래로 내려갈수록 레벨이이 증가 하므로 위에서 아래로 방문하고, 같은 레벨에서는 왼쪽에서 오른쪽으로 방문합니다.


이러한 순서는 어떻게 구현할 수 있을까요? 큐를 이용하면 간단하게 해결할 수 있습니다. 큐에 노드를 넣고 빼는 과정을 반복하는 것입니다. 맨 처음에는 공백 상태의 큐에 루트를 넣습니다. 다음부터는 큐에서 노드 하나를 꺼내 방문하고 그 노드의 자식들을 큐에 삽입하는 과정을 반복합니다. 삽입에도 순서가 있는데, 왼쪽 자식을 먼저 넣고 오른쪽 자식을 다음에 넣습니다. 물론 자식이 없으면 삽입하지 않습니다. 이 과정은 큐가 공백 상태가 될 때 까지 반복됩니다.


```python
	def levelorder(root):
		queue = ArrayQueue()
		queue.enqueue(root)
		while not queue.isEmpty():
			n = queue.dequeue()
			if n is not None:
				print(n.data, end=' ')
				queue.enqueue(n.left)
				queue.enqueue(n.right)
```

### 이진 트리의 연산들

1. 전체 노드의 수 구하기
    
    이진 트리에서 어떤 문제를 해결하기 위해서는 일단 순환을 떠올려보는 것이 좋습니다.
    
    
    ```python
    	def count_node(n):
    		if n is None:
    			return 0
    		else:
    			return count_node(n.left) + count_node(n.right) + 1
    ```
    
2. 트리의 높이 구하기
    
    
    ```python
    	def calc_height(n):
    		if n is None:
    			return 0
    		hLeft = calc_height(n.left)
    		hRight = calc_height(n.right)
    		if (hLeft > hRight):
    			return hLeft + 1
    		else: return hRight + 1
    ```
