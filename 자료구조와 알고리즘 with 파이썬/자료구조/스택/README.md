## 스택이란

자료의 입출력이 후입선출(LIFO: Last-In First-Out)의 형태로 제한되는 자료구조 입니다.

다른 통로들은 모두 막고 한쪽만 열어둔 구조입니다. 이 때 열린 곳을 보통 스택 상단(top)이라 부르고, 스택에 저장되는 것을 항목 또는 요소(elments)라 부릅니다. 스택은 요소의 삽입과 삭제가 상단에서만 가능한 자료 구조입니다.

### 추상 자료형

새로운 자료형을 정의하려면 그 자료형의 자세하고 복잡한 내용 대신 필수적이고 중요한 특징만 골라서 단순화하는 작업이 필요한데, 이를 추상화라고 합니다. 또한, 추상화를 정의한 자료형을 추상 자료형이라고 합니다. 스택의 추상 자료형은 **스택이 어떤 자료를 다루고, 어떤 연산이 필요한지 정의해보는것**으로 이해하면 됩니다.

### 스택의 연산

삽입과 삭제가 스택의 가장 핵심적인 연산인데, 이들은 스택의 상태를 변화시킵니다. 추가적인 연산들로는 스택의 상태를 검사하거나 스택 상단 요소를 살짝 들여다보는 기능 등이 있습니다.

peek는 pop과 비슷하게 상단 요소를 반환하지만, 연산 후에도 스택의 상태는 변화지 않습니다. 만약  스택이 peek를 지원하지 않는다면 pop으로 꺼낸 후 다시 push로 넣으면 원래 상태가 유지 됩니다.

isEmtpy와 isFull은 각각 스택의 공백 상태와 포화 상태를 검사하는데, 결과는 참 또는 거짓입니다. 스택을 적용하다보면 두가지 오류 상황을 만날 수 있습니다.

- 포화상태 삽입
    
    포화상태인 스택에 새로운 요소를 삽입하는 경우입니다. 입력이 더는 불가능 하므로 오류가 발생하는데, 이것을 오버플로우라고 합니다.
    
- 공백상태 삭제
    
    공백상태의 스택에서 pop(), peek()을 호출하면 삭제나 참조가 불가능하므로 언더플로우 오류가 발생합니다. 
    

## 배열 구조로 구현하기

### 자료구조의 구현 방법들

어떤 자료구조를 구현하는 방법은 크게 배열구조와 연결된 구조로 나눌 수 있습니다. 각각의 자료들을 메모리에 어떤 방식으로 저장하는가에 따라 구분됩니다.

- 배열 구조
    
    자료들을 배열에 모아 저장하는 방법을 말하는데, 모든 요소는 인접한 메모리 공간에 저장됩니다. 이것은 크기가 고정된 일반 공책과 비슷한데, 각 페이지를 쉽게 찾아 편리하게 사용할 수 있지만, 공책이 가득차면 더는 저장할 수 없습니다.
    
- 연결된 구조
    
    인접한 메모리가 아니라 흩어져 있는 요소들을 연결하여 하나로 관리하는 방법입니다. 이는 바인더 공책처럼 페이지의 위치를 바꾸거나 새로운 페이지를 쉽게 추가하고 삭제 할 수 있어 배열 구조보다 유용할 수 있지만, 그 만큼 관리하기 복잡합니다.

### 배열구조의 스택을 위한 데이터

배열은 요소들을 저장할 공간이고, 용량(capacity)은 이 공간의 크기로 한번만 들어지고 나면 고정되는 상수입니다. 상단을 위한 top은 인덱스를 저장하는 변수로, 가장 최근에 삽입된 요소의 위치를 가리키도록 하겠습니다.

```python
capacity = 10
array = [None] * capacity
top = -1
```

### 스택의 연산

- **공백 상태와 포화 상태 isEmpty()와 isFull 연산**
    
    스택이 비어 있는지 또는 가득 차 있는지는 top을 이용해 확인할 수 있습니다. 스택이 공백 일 때 top은 -1이고, 포화 상태면 top이 `capacity-1` 이 되는 것을 알 수 있습니다. 물론 검사 결과는 참(True)이나 거짓(False)이 될 것입니다. 
    
    ```python
    def isEmpty():
    	if top == -1:
    		return True
    	else:
    		return False
    		
    def isFull(): return top == capacity -1
    ```
    

- **새로운 요소 e를 삽입하는 push(e) 연산**
    
    삽입을 위해서는 먼저 top을 하나 증가 시켜야합니다. 다음에 그 위치에 삽입할 요소e를 복사하면 삽입이 완료됩니다. 그런데 이 삽입이 가능하려면 전제 조건이 있습니다. 포화 상태가 아니어야한다는 것입니다. 만약 스택이 포화 상태라면 오버플로 오류 상태가 되어 삽입은 불가능합니다. 따라서 push() 연산에서는 스택이 포화 상태가 아닌지를 검사해야합니다.
    
    ```python
    def push(e):
    	if not isFull():
    		top += 1
    		array[top] = e
    	else:
    		print("stack overflow")
    		exit()
    ```
    

- **상단 요소를 삭제하는 pop() 연산**
    
    삭제 연산이 가능하려면 스택에 최소한 하나 이상의 요소가 남아 있어야 합니다. 따라서 pop() 연산에서는 먼저 공백 상태를 검사해야 합니다. 공백이 아니면 top을 하나 감소 시키고, 이전 위치(top+1)의 요소를 반환하면 됩니다.
    
    만약 스택이 공백이라면 언더플로 오류가 발생합니다.
    
    ```python
    def pop():
    	if not isEmpty():
    		top -=1
    		return array[top+1]
    	else:
    		print("stack underflow")
    		exit()
    		
    ```
    

- **상단 요소를 들여다 보는 peek() 연산**
    
    peek()도 공백이 아니어야 가능한데, 단순히 top위치의 요소를 반환하면 됩니다.
    
    ```python
    def peek():
    	if not isEmpty():
    			return array[top]
    	else: pass
    ```
    

- **현재 스택 요소의 수를 반환하는 size() 연산**
    
    현재 스택의 요소 수는 top+1입니다.
    
    ```python
    def size(): return top+1
    ```
    

- **전역 변수와 함수 구현 방법의 문제점**
    
    이러한 스택 구현에는 여러 개의 스택이 동시에 필요한 문제에 사용할 수 없다는 것입니다. 전역 변수로 선언된 배열이 하나이므로 이 코드는 하나의 스택이 필요한 경우에만 사용할 수 있습니다.
    

### 스택을 클래스로 구현

자료구조는 함수를 기반으로 하는 절차적 프로그래밍보다는 클래스 기반으로 하는 **객체 지향 프로그래밍** 기법을 이용해 구현하는 것이 훨씬 좋습니다. 이것은 자료구조의 추상 자료형이 클래스 개념과 정확히 일치하기 때문입니다.

- **클래스의 선언과 멤버변수 초기화**
    
    파이썬에서는 클래스의 멤버변수들은 생성자(contructor)라는 이름으로 불리는 __init__() 함수에서 선언하고 초기화 합니다.
    
    ```python
    class ArrayStack:
    	def __init__(self, capacity):
    		self.capacity = capacity
    		self.array = [None] * self.capacity
    		self.top = -1
    ```
    
    생성자는 클래스의 객체가 만들어 질 때마다 자동으로 호출되는 함수입니다. 예를 들어, 다음 문장은 용량이 각각 20과 100인 ArrayStack 객체 s1과 s2를 생성하는데, 각 코드가 실행될 때 마다 생성자가 호출되어 스택의 데이터를 초기화 합니다.
    
    ```python
    s1 = ArrayStack(20)
    s2 = ArrayStack(100)
    ```
    
    C++이나 Java와는 다르게 파이썬에서는 생성자를 포함한 클래스의 모든 멤버함수의 첫 번째 매개변수로 스택 객체 자신을 나타내는 `self` 를 넣기로 약속되어 있습니다. 클래스의 모든 메서드에서 다른 메서드나 멤버 변수를 사용할때 반드시 `self` 을 추가해야합니다.
    
- **클래스의 연산**
    
    ```python
    	def isEmpty(self): return self.top == -1:
    			
    	def isFull(self): return self.top == self.capacity -1
    	
    	def push(self, e):
    		if not self.isFull():
    			self.top += 1
    			self.array[self.top] = e
    		else: pass
    		
    	def pop(self):
    		if not self.isEmpty():
    			self.top -=1
    			return self.array[self.top+1]
    		else: pass
    
    	def peek(self):
    		if not self.isEmpty():
    			return self.array[self.top]
    		else: pass
    	
    	def size(self): return self.top+1
    ```
    

### 스택 클래스의 사용

스택을 이용해 말을 거꾸로 뒤집는 프로그램을 만들어봅시다. 문자열을 입력받고, 입력된 문자들을 순서대로 스택에 모두 넣은 다음 하나씩 꺼내서 출력하기만 하면 됩니다.

```python
s = ArrayStack(100)

msg = input()
for c in msg:
	s.push(c)

while not s.isEmpty():
	print(s.pop(), end='')

print()
```

## 스택의 응용:괄호 검사

프로그램 코드나 HTML 문서 등에서는 여러 가지 종류의 괄호들이 사용됩니다. 예를 들어, C언어에서는 대괄호 [], 중괄호 {}, 소괄호 ()가 사용되는데, 프로그램이 정상적으로 컴파일되려면 괄호들이 반드시 쌍이 되도록 사용되어야 합니다. 

**괄호 검사 문제**란 소스코드나 주어진 문자열에서 괄호들이 올바르게 사용되었는지를 검사하는 문제입니다. 그렇다면 올바른 괄호 사용을 위한 조건들에는 어떤 것이 있을까요?

- 조건1: 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 합니다.
- 조건2: 같은 종류인 경우 왼쪽 괄호가 오른쪽 괄호보다 먼저 나와야 합니다.
- 조건3: 다른 종류의 괄호의 쌍이 서로 교차하면 안됩니다.


### 괄호 검사 알고리즘

앞의 문자열들을 자세히 살펴보면 자세히 살펴보면 가장 가까운 괄호들끼리는 서로 쌍을 이루어야 하고, 쌍을 이룬 괄호들은 더 이상 고려할 필요가 없다는 것을 알 수 있습니다. 이러한 괄호 검사를 위해 스택이 사용되는데, 검사 과정을 다음과 같습니다.

- 빈 스택을 준비
- 입력한 문자를 하나씩 읽어 왼쪽 괄호를 만나면 스택에 삽입
- 오른쪽 괄호를 만나면 가장 최근에 삽입된 괄호를 스택에서 꺼냅니다. 이때 스택이 비어 있다면 오른쪽 괄호가 먼저 나온 상황이므로 조건2에 위배
- 꺼낸 괄호가 오른쪽 괄호와 짝이 맞지 않다면 조건3에 위배
- 입력 문자열을 끝까지 처리했는데 스택에 괄호가 남아 있다면 괄호의 개수가 맞지 않으므로 조건 1위배.
- 모든 문자를 처리하고 스택이 공백이면 검사 성공


### 괄호 검사 프로그램

```python
def checkBrackets(statement):
	stack = ArrayStack(100)
	for ch in statement:
		if ch in ('(', '{', '['):
			stack.push(ch)
		elif ch in (')', '}', ']'):
			if stack.isEmpty():
				return False
			else: 
				left = stack.pop()
				if ch == '(' and left != ')':
					return False
				elif ch == '{' and left != '}':
					return False
				elif ch == '[' and left != ']':
					return False
	
	return stack.isEmpty()
```

## 파이썬에서 스택 사용하기

스택 클래스를 직접 만들어 사용할 수 있지만, 더 빠른 해결책이 있습니다. 파이썬에서 제공하는 것들을 이용하는 방법입니다.

### 파이썬 리스트를 스택으로 사용하기

가장 간단한 방법은 파이썬 리스트를 스택처럼 사용하는 것입니다. 즉, 리스트의 앞쪽이나 뒤쪽을 스택의 상단으로 생각하고, 그쪽으로만 자료를 넣거나 빼는 것입니다. 이때 리스트의 뒤쪽을 스택 상단으로 사용하는 것이 더 효율적입니다. 


```python
s = list()

msg = input()
for c in msg:
	s.push(c)
	
while len(s) > 0:
	print(s.pop(), end='')
```

### queue 모듈의 LifoQueue 사용하기

파이썬에서는 queue 모듈에서 큐나 스택(LifoQueue), 우선순위큐(PriorityQueue) 등 클래스로 제공해 줍니다.

따라서 이 모듈의 LifoQueue를 이용하면 스택을 따로 구현하지 않고도 해결할 수 있습니다. 클래스 이름이 Stack이 아니라 LifoQueue인 것에 유의하세요.


```python
import queue

s = queue.LifoQueue(maxsize = 100)

msg = input()
for c in msg:
	s.put(c)
	
while not s.empty():
	print(s.get(), end='')
```
## 시스탬 스택과 순환 호출

스택은 운영체제에서도 매우 중요한 역할을 합니다. 운영체제가 관리하는 메모리에는 스택 영역이 있는데 함수의 호출과 반환을 위해 사용됩니다. 예를 들어, 어떤 함수가 호출되면 그 함수가 끝나고 돌아갈 복귀 주소를 스택에 저장하고 호출된 함수를 위한 매개변수와 지연변수들을 스택에서 할당합니다. 이런 준비가 끝나면 프로그램은 호출된 함수의 시작 위치로 이동하여 수행을 시작하고, 함수의 수행이 끝나면 시스템 스택에서 복귀 주소를 추출하여 다시 호출된 함수로 되돌아 갑니다.

이러한 함수의 호출과 반환을 위해 시스템 스택이 사용되는데, 호출된 함수가 끝나면 가장 최근에 저장된 프로그램 정보를 꺼내 이전 함수의 상태로 손쉽게 복귀할 수 있습니다.

이러한 시스템 스택을 적극적으로 사용하는 프로그래밍 기법이 있습니다. 바로 순환입니다.

### 순환이란?

어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍 기법입니다. 어떤 함수가 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하기 때문입니다. 이러한 순환은 알고리즘들에서 사용되는 매우 중요한 개념입니다. 순환은 문제 자체가 순환적이거나(예: 팩토리얼 계산, 하노이 탑 등) 순환적으로 정의 되는 자료 구조(예: 이진 트리)를 다루는 프로그램에 적합합니다.

n의 팩토리얼은 n!은 다음과 같이 정의 할 수 있습니다.


이것은 곱셉을 반복해서 결과를 구합니다. 그런데 다른 방법도 있습니다. 그것은 **n!이 (n-1)!에 n을 곱하면 된다는 것을 이용**하는 것입니다. 일단 (n-1)!을 어떻게 구할지 걱정하지 맙시다. 어떻게든 구할 수 있다고 생각하면 n!은 다음과 같이 정의 할 수 있습니다.


이러한 정의를 **순환적(recursive)**이라고 합니다.  그렇다면 (n-1)!은 어떻게 구할까요? 마찬가지로 (n-2)!를 구한 다음 (n-1)을 곱해주면 되겠죠. (n-3)!, (n-4)!도 마찬가지입니다. 이 과정을 되풀이하다 보면 1!을 구해야하는데, 우리는 이미 1! 1이란것을 알고 있습니다.

### 팩토리얼의 두가지 구현

반복적인 정의에 의한 n!은 for 문 이용해 1부터 n까지를 반복해서 곱하면 됩니다.

```python
def factorial_iter(n):
	result = 1
	for k in range(2, n+1):
		result *= k
	return result;
```

순환적인 정의를 이용한 n!은 순환 호출을 이용하는데, 자기 자신을 다시 호출하는 것입니다.

```python
def factorial(n):
	if n == 1:
		return 1
	else:
		return n * factorial(n-1)

```

- 순환적으로 호출되는 부분에서는 호출할수록 문제의 크기가 반드시 작아져야 합니다.
- 순환 호출을 멈추는 부분이 반드시 있어야 합니다. 만약 코드에서 `if n == 1: return 1` 이 없다면 어떻게 될까요? factorial(3)을 구하기 위해 factorial(2)을 호출하고, 다시 factorial(1), factorial(0), factorial(-1), factorial(-2)을 계속 호출합니다. 이 과정에서 시스템의 스택 영역을 모두 사용할 때 까지 이어지다가 결국 오류를 내면서 프로그램이 종료됩니다.

### 순환적인 팩토리얼 함수 동작의 이해

순환적인 팩토리얼 함수를 이용해 3!을 구하는 과정을 생각해보겠습니다. 다음은 factorial(3)이 호출되어 결과를 반환할 때까지의 함수 호출과 반환, 그리고  시스템 스택의 변화를 보여줍니다.


팩토리얼 사례와 같이 순환 함수는 대부분 반복 구조로도 구현할 수 있습니다. 그렇다면 어떤 방법이 더 효율적일까요? 비교를 위해 두 함수에서 n!을 구하기 위해 곱셉(*)이 몇번 처리되는지를 살펴보겠습니다.

- 반복 구조 for 루프가 n-1번 반복되기 때문에 n-1번 처리 됩니다
- 순환 구조에서는 n이 1인 경우는 곱셉을 사용하지 않고 바로 결과를 반환합니다. 따라서 n-1번 처리됩니다.

결국 두 방법에서 곱셉 연산의 횟수는 차이가 없습니다. 그렇지만 순환은 함수 호출의한 부담이 있고, 시스템 스택을 많이 사용하기 때문에 대부분은 반복보다 느립니다. 예를 들어, 반복 함수 n이 매우 크더라도 추가적인 메모리 없이 반복해서 계산하지만, 순환 함수는 시스템 스택을 많이 이용해야 결과를 계산할 수 있습니다.

그렇지만 순환은 트리와 같은 특정한 문제에 대해 반복보다 훨씬 명확하고 간결한 코딩이 가능합니다. 또한, 이진 탐색이나 퀵 정렬 등과 같이 매우 효율적이고 유명한 알고리즘에서 흔히 사용되므로 잘 이해하는 것이 좋습니다.

### 하노이의 탑

복잡해 보이는 문제를 순환을 이용해 쉽게 해결할 수 있다는 것을 하노이의 탑 퍼즐을 통해 살펴보겠습니다.


<aside>
💡

막대 A에 쌓여 있는 n개의 원판을 모두 C로 옮기는 문제 입니다. 단, 다음과 같은 조건을 만족해야 합니다.

- 한 번에 하나의 원판만 옭길 수 있음
- 맨 위에 원판만 옮길 수 있음
- 크기가 작은 원판 위에 큰 원판을 쌓을 수 없음
- 중간 막대 B를 임시 막대로 사용할 수 있지만 앞의 조건을 지켜야함
</aside>

A에 있는 세 개의 원판을 모두 C로 옮기기 위해 7번의 이동이 필요한 것을 알 수 있습니다. 원판이 3개 뿐인데도 생각보다 이동이 많고 복잡한데 n개를 옮기려면 굉장히 어려울 것 같습니다. 그렇지만 순환을 사용하면 의외로 매우 간단하게 해결 할 수 있습니다.


순환 알고리즘에서는 호출할수록 문제의 크기가 작아져야 합니다. 그렇다면 하노이의 탑에서는 문제의 크기가 무엇일까요? 이동해야 하는 원판의 수가 많으면 더 많은 시간이 걸리므로, **원판의 수가 문제의 크기**입니다. 


이 아이디어에서 단계 2는 원판 1개의 원판만 바로 옮기면 됩니다. 문제는 n-1개의 원판을 단계 1과 3을 해결하는 것입니다.

- 단계 1은 n-1개의 원판을 옮기는 문제인데, 원래 문제보다 크기가 하나 줄었습니다. A에서 n-1개의 원판을 B로 옮기기 위해 비어 있는 C를 임시 막대로 사용하는 것은 문제가 없습니다. 또한, 움직이지 않는 A의 맨 아래 원판은 가장 큰 원판이므로 그 위에 있는 n-1개의 원판 중에서 어떤 것을 올려도 문제가 없습니다. 따라서 단계1은 순환으로 해결할 수 있습니다.
- 단계 3도 n-1개의 원판을 옮기는 문제입니다. 비어 있는 A를 임시 막대로 사용할 수 있고, C에는 가장 큰 원판이 있으므로 그 위에 나머지 어떤 원판을 올리더라도 문제가 없습니다. 마찬가지로 순환을 사용 할 수 있습니다.
- 순환 호출은 언제 멈출까요? 문제의 크기가 1인 경우입니다.

```python
def hanoi_tower(n, fr, tmp, to):
	if n == 1:
		print("원판 1: {} ---> {}".format(fr, to))
	else:
		hanoi_tower(n-1, fr, to, tmp) # 단계 1
		print("원판 {}: {} ---> {}".format(n,fr,to)) # 단계 2
		hanoi_tower(n-1, tmp, fr, to) # 단계 3
		
hanoi_tower(4, 'A', 'B', 'C')
```

- 단계 1은 fr 막대에 있는 n-1개의 원판을 to막대를 이용해 tmp 옮기면 됩니다.
- 단계 2는 fr에 있는 하나의 원판을 바로 to로 옮깁니다.
- 단계 3는 마지막 tmp에 있는  n-1개의 원판을 fr을 이용해 to로 옮깁니다.

