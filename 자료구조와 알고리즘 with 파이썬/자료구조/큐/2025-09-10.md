## 덱이란?

덱(deque)은 **double-ended queue**의 줄임말로서 전단과 후단에서 모두 삽입과 삭제가 가능한 큐를 말합니다. 그렇지만 여전히 중간에 삽입하거나 삭제하는 것은 허용하지 않습니다.


<aside>
💡 덱의 연산

- addFront(e): 새로운 요소 e를 전단에 추가
- addRear(e): 새로운 요소 e를 후단에 추가
- deleteFront(): 덱의 전단 요소를 꺼내서 반환
- deleteRear(): 덱의 후단 요소를 꺼내서 반환
- getFront(): 덱의 전단 요소를 삭제하지 않고 반환
- getRear(): 덱의 후단 요소를 삭제하지 않고 반환
- isEmpty(): 덱이 비어있으면 True를 아니면 False
- isFull(): 덱이 가득 차 있으면 True를 아니면 False
- size(): 덱에 들어 있는 전체 요소의 수를 반환
</aside>

덱은 스택과 큐의 연산을 모두 가지고 있습니다.

- 덱의 `addRear` , `deleteFront` , `getFront` 연산은 각각 큐의 `enqueue` , `dequeue` , `peek` 연산과 동일합니다.
- 덱의 후단(rear)을 스택 상단(top)으로 사용한다면, 덱의 `addRear` , `deleteRear` , `getRear` 연산은 스택의 `push` , `pop` , `peek` 연산과 동일합니다.

덱의 구현도 원형 큐와 비슷하게 원형 덱(circular deque)으로 구현하는 것이 좋습니다. 이때 주의해야 할 연산은 front와 rear를 감소시켜야 하는 deleteRear와 addFront입니다. 이들은 원형 큐의 enqueue나 dequeue 연산과는 달리 인덱스를 하나씩 줄여야하는데, 이것은 **반시계 방향 회전**을 의미 합니다. 이를 위한 인덱스 처리는 나머지 연산을 이용해 간결하게 할 수 있습니다.

- 전단 회전(반시계 방향): front ← (front -1 + capacity) % capacity
- 후단 회전(반시계 방향): rear ← (rear -1 + capacity) % capacity


후단 삭제를 위한 `deleteRear()` 를 수행하면 (b)와 같이 rear는 3에서 2로 줄어듭니다. 또한, (b)에서 전단 삽입을 위해 `addFront(D)` 를 수행하면 (c)와 같이 front는 0에서 7(=(0-1+8)%8)로 회전합니다.

## 상속을 이용한 덱의 구현

원형 덱은 어떻게 구현할 수 있을까요? 먼저 떠오르는 방법은 원형 큐와 같이 클래스를 만들고 각 연산을 하나씩 구현해 넣는 것입니다. 그런데 좀 더 편리한 방법이 있습니다. **상속(inheritance)**이라는 객체지향 프로그래밍 기법을 사용하는 것입니다. 


`isEmpty`, `isFull`, `size` 연산은 이름과 동작이 모두 같고, `deleteFront` , `getFront` , `addRear` 는 큐에 있는 연산인데 이름만 바뀐 것입니다. 새로 추가되는 연산은 `addFront`, `getRear`, `deleteRear` 뿐입니다.

상속은 매우 짧은 코드로 기존의 복잡한 클래스에 기능을 추가한 새로운 클래스를 만들 수 있는 매우 유용한 방법 입니다. 원형 큐를 상속해서 원형 덱을 구현하면 다음과 같은 장점들이 있습니다.

- 데이터는 추가로 정의할 필요없음
- `isEmpty`, `isFull` 도 추가로 정의할 필요 없음
- `deleteFront` , `getFront` , `addRear` 는 구현해야 하지만 단순히 원형 큐의 `enqueue` , `dequeue` , `peek` 연산을 호출하면 됨
- `addFront`, `getRear`, `deleteRear`  새로 구현

### 원형 큐를 상속하여 구현하는 원형 덱 클래스

- **클래스의 상속과 멤버변수 초기화**

앞에서 구현한 원형 큐 클래스 ArrayQueue를 상속하여 새로운 원형 덱 클래스 CircularDeque를 만들어 보겠습니다.

```python
class CircularDeque(AraayQueue):
	def __init__( self, capacity=10):
		super().__init__(capacity)
```

생성자에서 front, rear, array와 같은 변수를 선언하지 않았지만 이들은 부모 클래스의 데이터 멤버이므로 이미 자식 클래스에 들어있습니다. 따라서 자식 클래스에서 self.front와 같이 바로 사용하면 됩니다.

- **addRear(e), deleteFront(), getFront() 연산**

이 연산들은 원형 큐에 이미있지만 이름이 다릅니다. 따라서 이들은 자식 클래스에 멤버함수로 추가하고, 이미 구현된 부모 클래스의 해당 연산을 호출하면 됩니다.

```python
	def addRear( self, item ): self.enqueue(item)
	def deleteFront(self): return self.dequeue()
	def getFront(self): return self.peek()
```

- **addFront(e), deleteRear(), getRear() 연산**

```python
	def addFront( self, item ):
		is not self.isFull():
			self.array[self.front] = item
			self.front = (self.front -1 + self.capacity) % self.capacity
		else: pass
	
	def deleteRear(self):
		is not self.isEmpty():
			item = self.array[self.rear]
			self.rear = (self.rear - 1 + self.capacity) % self.capacity
			return item
		else: pass
		
	def getRear(self):
		is not self.isEmpty():
			return self.array[self.rear]
		else: pass
```

### 원형 덱의 활용

```python
dq = CirularDeque()

for i in range(9):
	if i%2==0: dq.addRear(i)
	else: dq.addFront(i)

dq.display("홀수는 전단 짝수는 후단 삽입")

for i in range(2): dq.deleteFront()
for i in range(3): dq.deleteRear()
dq.display("전단 삭제 2번, 후단 삭제 3번")

for i in range(9,14): dq.addFront(i)
dq.display("전단에 9 ~ 13 삽입")
```


## 파이썬에서 큐와 덱 사용하기

파이썬 리스트는 스택으로 사용하기는 충분하지만, 원형 큐나 덱으로 직접 사용하기에는 적절하지 않습니다. 따라서 파이썬에서 제공하는 모듈을 사용하는 것이 좋습니다.

### queue 모듈의 Queue 사용하기

파이썬 queue 모듈은 스택과 함께 큐를 제공해 주는데, 큐 클래스 이름은 Queue입니다. 

```python
import queue
q = queue.Queue(maxsize-20)
```

maxsize는 큐의 용량인데, 만약 maxsize가 0이면 용령의 제한이 없는(무한대의) 큐 객체를 만든다는 의미입니다.


```python
import queue
import random

q = queue.Queue(8)

print("삽입 순서: ", end='')
while not q.full():
	v = random.randint(0,100)
	q.put(v)
	print(v, end=' ')
print()

print('삭제 순서: ', end='')
while not q.empty():
	print(q.get(), end=' ')
print()
	
```

### collections모듈의 deque 클래스 사용하기

파이썬은 `collections` 라는 모듈에서 내장 자료형인 튜플이나 딕셔너리에 대한 확장 데이터 구조들을 제공하는데, `defaultdict` , `counter` , `deque` , `namedtuple` 등 다양한 클래스를 포함하고 있습니다.

```python
import collections
dq = collections.deque()
```


```python
import collections
dq = collections.deque()

print("덱은 공백 상태 아님" if dq else "덱은 공백 상태")
for i in range(9):
	if i%2 == 0: dq.append(i)
	else: dq.appendleft(i)
print("홀수는 전단 짝수는 후단 삽입", dq)

for i in range(2): dq.popleft()
for i in range(3): dq.pop()
print("전단 삭제 2번, 후단 삭제 3번",  dq)

for i in range(9,14): dq.appendleft(i)
print("전단에 9 ~ 13 삽입        ", dq)

print("덱은 공백 상태 아님" if dq else "덱은 공백 상태")
```
