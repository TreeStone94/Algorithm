## 배열 구조와 연결된 구조

리스트도 배열 구조와 연결된 구조로 구현할 수 있습니다.

**모든 요소는 중간에 빈자리가 없이 반드시 메모리의 연속된 공간에 저장**되어야 합니다. 요소들이 연속된 공간에 있으면 원하는 위치의 요소를  빠르게 참조하고 관리할 수 있습니다.


이에 비해, 연결된 구조에서는 요소들을 메모리의 한군데 모아두는 것을 포기합니다. 즉, 요소들이 메모리의 여기저기에 흩어져서 저장되는 것입니다. 그렇다면 흩어진 요소들은 어떻게 순서대로 관리할 수 있을까요? **링크(link)**를 이용하면  됩니다. 즉, 요소들이 다른 요소를 가리키는 하나 이상의 링크를 갖도록 하여 전체를 순서대로 연결해 관리하는 것입니다.

이처럼 메모리에 흩어져 있는 요소들을 링크로 연결해 하나로 관리하는 것을 **연결된 구조(linked structure)**라고 합니다. 특히 자료들을 링크를 통해 일렬로 나열할 수 있는 연결된 구조를 **연결 리스트(linked list)**라고 부릅니다. 연결된 구조에서 하나의 상자를 노드(node)라고 부르는데, 데이터와 함께 링크를 갖습니다. 배열 구조와는 달리 하나의 요소를 표현하기 위해 링크가 추가로 필요한 것에 유의하세요. 연결된 구조에서는 이러한 링크의 수를 여러 개로 늘리면 리스트와 같은 선형 자료 구조뿐만 아니라 트리나 그래프와 같이 훨씬 복잡한 구조들도 효율적으로 표현 할 수 있습니다.

### 배열 구조의 리스트와 연결 리스트의 비교

1. **리스트 요소들에 대한 접근**


그림과 같이 리스트에서 원하는 요소에 접근하는 연산은 배열 구조가 훨씬 유리합니다. 그렇다면 연결된 구조를 왜 사용할까요? 당연히 그만한 장점이 있기 때문입니다.

1. **리스트의 용량**

기본적으로 배열은 용량이 고정됩니다. 고정된 용량은 중간에 부족하다고 늘리거나 필요 없다고 줄이기 어렵습니다. 리스트를 위해 배열을 사용할 때, 만약 배열을 무턱대고 너무 크게 할당해 놓으면 메모리 낭비가 심할 것입니다. 그렇다고 너무 적게 할당하면 빨리 포화 상태가 되어 새로운 요소를 넣지 못하는 상황이 발생합니다.


연결된 구조는 용량이 고정되어 있지 않습니다. 필요할 때 필요한 크키만큼 새로 할당해서 사용하는 것입니다. 따라서 메모리를 효율적으로 사용할 수 있습니다. 또한, 컴퓨터에 메모리가 남아 있는 한 계속 자료를 넣을 수 있습니다. 포화 상태가 될 수 없습니다.


1. **리스트의 삽입 연산**

배열 구조에서는 중간에 자료를 삽입하려면 그 위치 이후 모든 요소를 한 칸씩 뒤로 밀어야 합니다. 이처럼 배열 구조의 삽입은 많은 요소의 이동이 필요합니다. 


연결된 구조에서는 삽입할 위치를 알고 있다면 효율적인 삽입이 가능합니다. 그림과 같이 97의 링크와 새로운 요소 61의 링크만 수정하면 됩니다. 그 외의 다른 노드들은 전혀 영향을 받지 않는다는 것에 유의하세요. 결국, 연결된 구조의 삽입이 훨씬 효율적입니다.

1. **리스트의 삭제 연산**

삭제 연산도 마찬가지입니다. 배열 구조에서는 중간에 있는 자료를 삭제하면 이후의 모든 자료를 앞으로 당겨 빈 곳이 생기지 않도록 해야합니다. 만약 삭제할 요소가 앞쪽이라면 리스트의 요소 대부분을 이용해야 하므로 매우 비효율적입니다. 


이에 비해, 연결된 구조에서는 삭제할 노드 바로 앞 노드의 링크만 수정하면 되고, 다른 노드들은  수정할 필요가 없습니다. 결국, 연결된 구조의 삭제가 훨씬 효율적입니다.

| 배열 구조 | 연결된 구조 | 기능 | 효율성 |
| --- | --- | --- | --- |
| 연속된 구조 | 연결 구조 | 접근 | 배열 구조 |
| 용량 고정 | 용량 고정 X | 용량 | 연결된 구조 |
| 요소들의 많은 수정 필요 | 요소들의 적은 수정 | 삽입/삭제 | 연결된 구조 |
