## 배열 구조의 리스트

파이썬의 리스트는 클래스로 구현되어 있는데 다양한 연산들을 메서드로 지원합니다.


### 파이썬 리스트는 용량 제한 없음

파이썬 리스트는 배열 구조를 사용하지만 용량이 제한되지 않도록 내부적으로 구현되어 있습니다. 용량이 8인 리스트 8개의 요소가 삽입되면 이제 리스트에는 여유 공간이 없습니다. 이 상태에서 `append(I)` 연산을 시도하면 어떻게 될까요? 만약 용량이 제한된 리스트라면 이 연산을 성공적으로 처리하지 못합니다.

그렇지만 파이썬 리스트는 이러한 상황을 용량을 늘리는 방법으로 해결합니다.


그렇다면 `append()` 연산은 얼마나 효율적일까요? 리스트의 용량이 포화되기 전이라 매우 빨리 처리됩니다. 만약 리스트가 포화 상태라면 위에 그림과 같이 처리가 필요하므로 훨씬 많은 시간이 거립니다. 메모리를 할당하고, 기존의 요소를 모두 복사하는 작업이 추가되어야 하기 때문입니다. 결국  파이썬 리스트의 append()연산은 처리 시간이 항상 같지는 않습니다. 그렇지만 용량 확장해야 하는 경우가 가끔 발생하고, 대부분은 여유 공간이 있어 빠르게 처리됩니다. 특히, 용량 확장은 내부적으로 처리되므로 리스트를 사용하는 사용자는 신경을 쓰지 않아도 됩니다.

## 연결된 리스트의 구조와 종류

### 연결 리스트의 구조

1. **노드**

연결 리스트에서 하나의 노드는 하나의 데이터와 함께 하나 이상의 링크를 갖습니다. 이 때 데이터는 배열 구조에서의 요소를 말하는데, 리스트에 저장하고 싶은 자료에 해당합니다. 링크는 다른 노드를 가리키는(다른 노드의 주소를 저장하는) 변수입니다. 배열 구조에 비해 연결된 구조에서는 링크를 위한 추가 공간이 필요합니다. 그러나 대부분은 데이터가 훨씬 크므로 링크를 위한 공간은 무시할 수 있습니다.

1. **헤드 포인터**

연결 리스트는 시작 노드만 알면 링크로 매달려 있는 모든 노드에 순차적으로 접근할 수 있는데, 이 노드를 보통 **머리 노드(head node)**라고 부릅니다. 머리 노드의 주소를 저장하는 변수를 **헤드 포인터(head pointer)**라고 하는데, 연결 리스트의 가장 중요한 정보입니다. 마지막 노드를 보통 **꼬리 노드(tail node)**라고 부르는데, 꼬리 노드의 링크를 처리하는 방법에 따라 단순 연결과 원형 연결로 구분됩니다.


### 연결 리스트의 종류

1. **단순 연결 리스트(singly linked list)**

하나의 방향으로만 연결된 리스트를 말합니다. 노드는 하나의 링크를 갖는데, 다음 노드의 주소가 저장됩니다.

1. **원형 연결 리스트(cirucular linked list)**

꼬리 노드의 링크를 약간 다르게 사용하면 원형으로 연결된 구조를 만들 수있습니다. 이러한 원형 연결 구조에서는 어떤 노드에서 시작해도 다른 모든 노드를 찾아 갈 수 있습니다. 하지만 노드들을 순서대로 방문할 때 종료 조건 처리에 매우 조심해야 합니다.


1. **이중 연결 리스트(doubly linked list)**

하나의 노드가 이전 노드와 다음 노드의 링크를 모두 갖도록 설계되었습니다. 두개의 링크를 갖는데, 하나는 이전 노드를, 다른 하나는 다음 노드를 가리키도록 하는 것입니다.


이전 노드를 위한 링크가 있으면 어떤 노드에서 이전 노드를 바로 찾아갈 수 있다는 장점이 있습니다. 편리한 만큼 링크를 이중으로 정확히 유지해야 하므로 코드가 복잡해집니다.


## 단순 연결 구조로 리스트 구현

### 노드 클래스 구현

```python
class Node:
	def __init__(self, elem, link=None):
		self.data = elem
		self.link = link
		
		def append(self, node):
			if node is not None:
				node.link = self.link
				self.link = node
			
		def popNext(self):
			next = self.link
			if next is not None:
				self.link = next.link
			return next
```

### 연결 리스트 클래스

연결된 구조에서는 리스트 클래스의 데이터 멤버로 어떤 것이 필요할까요? 의외로 단순합니다. 머리노드를 가리킬 변수 하나만 있으면 되는데 이를 head라 하겟습니다.


리스트가 공백 상태인 경우와 노드가 추가된 예를 보여주고 있는데, 전체 리스트를 관리하기 위해서는 head만 잘 처리하면 된다는 것을 알 수 있습니다.


```python
class LinkedList:
	def __init__(self):
		self.head = None
	
	def isEmpty(self):
		return self.head == None
	
	def isFull(self):
		return False # 연결된 구조에서는 포화 상태 없음
	
	def getNode(self, pos):
		if pos < 0: return None
		ptr = self.head
		for i in range(pos):
			if ptr == None:
				return None
			ptr = ptr.link
		return ptr
	
	def getEntry(self,pos):
		node = self.getNode(pos)
		if node == None: return Node
		else: return node.data
		
	def insert(self,pos,e):
		node = Node(e, None)
		before = self.getNode(pos-1)
		if before == None:
			node.link = self.head # 원래 head가 가리키고 있는 node를 삽입한 node가 가리키도록 함
			self.head = node
		else: before.append(node)
	
	def delete(self,pos):
		before = self.getNode(pos-1)
		if before == None:
			before = self.head
			if self.head is not None:
				self.head = self.head.link
			return before
		else: return before.popNext()
	
	def replace(self, pos, elem) :
     node = self.getNode(pos)
     if node != None : node.data = elem
			
	def size(self):
		ptr = self.head
		count = 0
		while ptr is not None:
			ptr = ptr.link
			count +=1
		return count
		
	def display(self, msg='LinkedList:'):
		print(msg, end='')
		ptr = self.head
		while ptr is not None:
			print(ptr.data, end='->')
			ptr = ptr.link
		print('None')
```

## 이중 연결 구조로 리스트 구현

### 이중 연결 구조 노드 클래스

```python
class DNode:
	def __init__(self, elem, prev=None, next=None):
		self.data = elem
		self.next = next
		self.prev = prev
	def append(self,node):
		if node is not None:
			node.next = self.next
			node.prev = self
			if node.next is not None:
				node.next.prev = node
			self.next = node
	def popNext(self):
			node = self.next
			if node is not None:
				self.next = node.next
				if self.next is not None:
					self.next.prev = self
			return node
```

### 이중 연결 리스트 클래스

```python
class DblLinkedList:
	def __init__(self):
		self.head = None
	
	def display(self, msg='DblLinkedList:'):
		print(msg, end='')
		ptr = self.head
		while ptr is not None:
			print(ptr.data, end='<=>')
			ptr = ptr.next
		print('None')
	
	def insert(self, pos, e):
		node = DNode(e)
		before = self.getNode(pos-1)
		if before == None:
			node.next = self.head
			if node.next is not None:
				node.next.prev = node
			self.head = node
		else: before.append(node)
	
	def delete(self,pos):
		before = self.getNode(pos-1)
		if before == None:
			before = self.head
			if self.head is not None:
				self.head = self.head.next
			if self.head is not None:
				self.head.prev = None
			return before
		else: before.popNext()
```
