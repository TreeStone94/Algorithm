## 시스탬 스택과 순환 호출

스택은 운영체제에서도 매우 중요한 역할을 합니다. 운영체제가 관리하는 메모리에는 스택 영역이 있는데 함수의 호출과 반환을 위해 사용됩니다. 예를 들어, 어떤 함수가 호출되면 그 함수가 끝나고 돌아갈 복귀 주소를 스택에 저장하고 호출된 함수를 위한 매개변수와 지연변수들을 스택에서 할당합니다. 이런 준비가 끝나면 프로그램은 호출된 함수의 시작 위치로 이동하여 수행을 시작하고, 함수의 수행이 끝나면 시스템 스택에서 복귀 주소를 추출하여 다시 호출된 함수로 되돌아 갑니다.

이러한 함수의 호출과 반환을 위해 시스템 스택이 사용되는데, 호출된 함수가 끝나면 가장 최근에 저장된 프로그램 정보를 꺼내 이전 함수의 상태로 손쉽게 복귀할 수 있습니다.

이러한 시스템 스택을 적극적으로 사용하는 프로그래밍 기법이 있습니다. 바로 순환입니다.

### 순환이란?

어떤 함수가 자기 자신을 다시 호출하여 문제를 해결하는 프로그래밍 기법입니다. 어떤 함수가 자신을 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하기 때문입니다. 이러한 순환은 알고리즘들에서 사용되는 매우 중요한 개념입니다. 순환은 문제 자체가 순환적이거나(예: 팩토리얼 계산, 하노이 탑 등) 순환적으로 정의 되는 자료 구조(예: 이진 트리)를 다루는 프로그램에 적합합니다.

n의 팩토리얼은 n!은 다음과 같이 정의 할 수 있습니다.


이것은 곱셉을 반복해서 결과를 구합니다. 그런데 다른 방법도 있습니다. 그것은 **n!이 (n-1)!에 n을 곱하면 된다는 것을 이용**하는 것입니다. 일단 (n-1)!을 어떻게 구할지 걱정하지 맙시다. 어떻게든 구할 수 있다고 생각하면 n!은 다음과 같이 정의 할 수 있습니다.


이러한 정의를 **순환적(recursive)**이라고 합니다.  그렇다면 (n-1)!은 어떻게 구할까요? 마찬가지로 (n-2)!를 구한 다음 (n-1)을 곱해주면 되겠죠. (n-3)!, (n-4)!도 마찬가지입니다. 이 과정을 되풀이하다 보면 1!을 구해야하는데, 우리는 이미 1! 1이란것을 알고 있습니다.

### 팩토리얼의 두가지 구현

반복적인 정의에 의한 n!은 for 문 이용해 1부터 n까지를 반복해서 곱하면 됩니다.

```python
def factorial_iter(n):
	result = 1
	for k in range(2, n+1):
		result *= k
	return result;
```

순환적인 정의를 이용한 n!은 순환 호출을 이용하는데, 자기 자신을 다시 호출하는 것입니다.

```python
def factorial(n):
	if n == 1:
		return 1
	else:
		return n * factorial(n-1)

```

- 순환적으로 호출되는 부분에서는 호출할수록 문제의 크기가 반드시 작아져야 합니다.
- 순환 호출을 멈추는 부분이 반드시 있어야 합니다. 만약 코드에서 `if n == 1: return 1` 이 없다면 어떻게 될까요? factorial(3)을 구하기 위해 factorial(2)을 호출하고, 다시 factorial(1), factorial(0), factorial(-1), factorial(-2)을 계속 호출합니다. 이 과정에서 시스템의 스택 영역을 모두 사용할 때 까지 이어지다가 결국 오류를 내면서 프로그램이 종료됩니다.

### 순환적인 팩토리얼 함수 동작의 이해

순환적인 팩토리얼 함수를 이용해 3!을 구하는 과정을 생각해보겠습니다. 다음은 factorial(3)이 호출되어 결과를 반환할 때까지의 함수 호출과 반환, 그리고  시스템 스택의 변화를 보여줍니다.


팩토리얼 사례와 같이 순환 함수는 대부분 반복 구조로도 구현할 수 있습니다. 그렇다면 어떤 방법이 더 효율적일까요? 비교를 위해 두 함수에서 n!을 구하기 위해 곱셉(*)이 몇번 처리되는지를 살펴보겠습니다.

- 반복 구조 for 루프가 n-1번 반복되기 때문에 n-1번 처리 됩니다
- 순환 구조에서는 n이 1인 경우는 곱셉을 사용하지 않고 바로 결과를 반환합니다. 따라서 n-1번 처리됩니다.

결국 두 방법에서 곱셉 연산의 횟수는 차이가 없습니다. 그렇지만 순환은 함수 호출의한 부담이 있고, 시스템 스택을 많이 사용하기 때문에 대부분은 반복보다 느립니다. 예를 들어, 반복 함수 n이 매우 크더라도 추가적인 메모리 없이 반복해서 계산하지만, 순환 함수는 시스템 스택을 많이 이용해야 결과를 계산할 수 있습니다.

그렇지만 순환은 트리와 같은 특정한 문제에 대해 반복보다 훨씬 명확하고 간결한 코딩이 가능합니다. 또한, 이진 탐색이나 퀵 정렬 등과 같이 매우 효율적이고 유명한 알고리즘에서 흔히 사용되므로 잘 이해하는 것이 좋습니다.

### 하노이의 탑

복잡해 보이는 문제를 순환을 이용해 쉽게 해결할 수 있다는 것을 하노이의 탑 퍼즐을 통해 살펴보겠습니다.


<aside>
💡

막대 A에 쌓여 있는 n개의 원판을 모두 C로 옮기는 문제 입니다. 단, 다음과 같은 조건을 만족해야 합니다.

- 한 번에 하나의 원판만 옭길 수 있음
- 맨 위에 원판만 옮길 수 있음
- 크기가 작은 원판 위에 큰 원판을 쌓을 수 없음
- 중간 막대 B를 임시 막대로 사용할 수 있지만 앞의 조건을 지켜야함
</aside>

A에 있는 세 개의 원판을 모두 C로 옮기기 위해 7번의 이동이 필요한 것을 알 수 있습니다. 원판이 3개 뿐인데도 생각보다 이동이 많고 복잡한데 n개를 옮기려면 굉장히 어려울 것 같습니다. 그렇지만 순환을 사용하면 의외로 매우 간단하게 해결 할 수 있습니다.


순환 알고리즘에서는 호출할수록 문제의 크기가 작아져야 합니다. 그렇다면 하노이의 탑에서는 문제의 크기가 무엇일까요? 이동해야 하는 원판의 수가 많으면 더 많은 시간이 걸리므로, **원판의 수가 문제의 크기**입니다. 


이 아이디어에서 단계 2는 원판 1개의 원판만 바로 옮기면 됩니다. 문제는 n-1개의 원판을 단계 1과 3을 해결하는 것입니다.

- 단계 1은 n-1개의 원판을 옮기는 문제인데, 원래 문제보다 크기가 하나 줄었습니다. A에서 n-1개의 원판을 B로 옮기기 위해 비어 있는 C를 임시 막대로 사용하는 것은 문제가 없습니다. 또한, 움직이지 않는 A의 맨 아래 원판은 가장 큰 원판이므로 그 위에 있는 n-1개의 원판 중에서 어떤 것을 올려도 문제가 없습니다. 따라서 단계1은 순환으로 해결할 수 있습니다.
- 단계 3도 n-1개의 원판을 옮기는 문제입니다. 비어 있는 A를 임시 막대로 사용할 수 있고, C에는 가장 큰 원판이 있으므로 그 위에 나머지 어떤 원판을 올리더라도 문제가 없습니다. 마찬가지로 순환을 사용 할 수 있습니다.
- 순환 호출은 언제 멈출까요? 문제의 크기가 1인 경우입니다.

```python
def hanoi_tower(n, fr, tmp, to):
	if n == 1:
		print("원판 1: {} ---> {}".format(fr, to))
	else:
		hanoi_tower(n-1, fr, to, tmp) # 단계 1
		print("원판 {}: {} ---> {}".format(n,fr,to)) # 단계 2
		hanoi_tower(n-1, tmp, fr, to) # 단계 3
		
hanoi_tower(4, 'A', 'B', 'C')
```

- 단계 1은 fr 막대에 있는 n-1개의 원판을 to막대를 이용해 tmp 옮기면 됩니다.
- 단계 2는 fr에 있는 하나의 원판을 바로 to로 옮깁니다.
- 단계 3는 마지막 tmp에 있는  n-1개의 원판을 fr을 이용해 to로 옮깁니다.
