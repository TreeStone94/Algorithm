## 큐란?

큐는 가장 먼저 들어간 자료가 가정 먼저 나오는 자료구조입니다. 큐는 매표소의 대기줄을 떠올리면 쉽게 이해할 수 있습니다. 매표소에서는 먼저 온 사람이 먼저 표를 사게 되고, 방금 도착한 사람은 줄을 서 있는 사람들의 맨뒤에서 자신의 순서를 기다려야 합니다.

큐는 이처럼 먼저 들어온 데이터가 먼저 나가는 **선입선출(FIFO: First-in First-Out)**의 특성을 갖는 자료구조입니다. 큐는 스택과 비슷해 보이지만 삽입과 삭제 연산이 같은 쪽이 아니라 서로 다른 쪽에서 일어난다는 근복적인 차이가 있습니다. 즉, A, B, C를 순서대로 넣으면(삽입) 꺼낼(삭제) 때도 같은 순서인 A, B, C로 나오게 됩니다. 이때 삽입이 일어나는 곳을 **후단(rear)**이라고 하고 삭제가 일어나는 곳을 **전단(front)**이라 부릅니다.


일상생활에서 많은 일들이 발생한 순서대로 처리되어야 하는 것처럼 컴퓨터에서도 큐가 필요한 곳은 매우 광범위합니다. 예를 들어, 컴퓨터와 주변 기기 사이에는 항상 큐가 있는데, 컴퓨터의 빠른 CPU와 속도가 상대적으로 느린 주변장치(예: 프린터)들 **사이의 시간이나 속도 차이를 극복하기 위한 임시 기억장치(Buffer)**로 사용됩니다. 또한, 컴퓨터로 현실 세계를 시뮬레이션하는 분야에서도 큐가 폭넓게 사용됩니다. 이러한 큐는 다양한 알고리즘에서도 흔히 사용되는 매우 중요한 도구입니다.

### 큐의 연산

스택과 마찬가지로 큐에도 숫자나 문자열을 포함한 어떤 자료든 저장할 수 있습니다. 연산도 스택과 유사합니다. 큐에서도 역시 삽입과 삭제가 가장 핵심적인 연산이고, 큐의 상태를 살피는 연산들을 다암과 같이 추가할 수 있습니다.

<aside>
💡 큐의 연산

- enqueue(e): 새로운 요소 e를 큐의 맨뒤에 추가
- dequeue(): 큐의 맨 앞에 있는 요소를 꺼내서 반환
- isEmpty(): 큐가 비어 있으면 True, 아니면 False 반환
- peek(): 큐의 맨 앞에 있는 요소를 삭제하지 않고 반환
- size(): 큐에 들어 있는 전체 요소의 수를 반환
</aside>


큐에서도 두 가지 오류 상황을 만날 수 있는데, 포화 상태인 큐에 `enqueue()` 연산을 실행하는 경우 오버플로 오류와 공백인 큐에서 `dequeue()` 나 `peek()` 연산을 실행하는 경우 발생하는 언더플로 오류입니다.

## 배열로 구현하는 큐

큐도 배열 구조와 연결된 구조로 구현할 수 있습니다.

### 배열 구조의 큐를 위한 데이터


- array[]: 큐 요소들을 저장하는 배열
- capacity: 큐에 저장할 수 있는 요소의 최대 개수
- rear: 맨 마지막(후단) 요소의 위치(인덱스)
- front: 첫 번째(전단) 요소 바로 이전의 위치(인덱스)

배열과 용량은 스택에서와 동일합니다. 스택에서 상단(top)만 사용한 것에 비해 큐는 두개의 변수가 필요한데, 삽입과 삭제가 다른 쪽에서 이루어져야하기 때문입니다. 먼저 후단을 나타내는 rear는 큐의 마지막 요소를 가리키면 됩니다. front는 큐의 첫번째 요소가 아니라 그 요소 바로 앞의 위치를 가리키도록 하겠습니다.

삽입 연산은 rear를 먼저 하나 증가시킨 후 그 자리에 새로운 요소를 넣으면 됩니다. 삭제 연산은 front를 하나 증가시킨 후 그 자리의 요소를 반환하면 됩니다. 맨 처음에는 큐가 공백이어야 하므로 front와 rear를 모두 -1로 초기화 합니다.
