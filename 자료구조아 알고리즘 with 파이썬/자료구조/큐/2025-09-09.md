### 선형 큐의 문제점과 원형 큐의 원리

용량이 5인 공백 상태의 큐에 요소 A~E를 삽입(enqueue)하고 두번의 삭제(dequeue)를 순서대로 수행했다고 생각해 봅시다.  이 상태에서 F를 삽입(enqueue(F))하려면 문제가 생깁니다. 큐의 앞부분에 공간이 있는데도 rear를 더 증가 시킬 수 없으므로 새로운 요소 F를 후단에 삽입할 수 없는 것입니다.


그렇다면 어떻게 해야 할까요? 어쩔 수 없이 큐의 요소들을 모두 최대한 앞으로 옮겨 후단에 공간을 확보한 다음 삽입해야 합니다. 이렇게 동작하는 큐를 **선형 큐(linear queue)**라고 하는데, 동작을 이해하기는 쉽지만 요소들의 이동이 필요하므로 효율적이지 않습니다.

이러한 선형큐의 문제를 깔끔하게 해결할 수 있는 아이디어가 있습니다. 배열을 선형이 아니라 원형으로 생각하는 것입니다. 이러한 큐를 **원형 큐(circular queue)**라고 하는데, 실제로 배열이 원형이 되는 것이 아니라 인덱스 **front와 rear를 원형으로 회전시키는 개념**입니다. `enqueue(F)` 가 호출되면 오른쪽과 같이 rear를 시계 방향으로 한칸 회전시키고 그 위치에 F를 저장하는 것입니다.


시계 방향의 회전은 어떻게 할까요? front나 rear가 계속 증가하다가 용량(capacity)과 같아지면 이들을 다시 0으로 만들어주면 됩니다. 이것은 If와 같은 조건문으로 처리할 수도 있지만, 다음과 같이 나머지 연산(%)을 이용하면 더 간격하게 처리 됩니다.

- 전단 회전: front ← (front+1) % capacity
- 후단 회전: rear ← (rear+1) % capacity

예를 들어, 삽입과 관련된 rear는 0, 1, 2, 3, 4의 순으로 증가하다가 (4+1)%5가 되어 다시 0으로 되돌아갑니다. 삭제와 관련된 front도 같은 방법으로 시계 방향으로 회전 합니다. 

### 원형 큐의 클래스 구현

- **클래스 선언과 멤버변수 초기화**

```python
class ArrayQueue :
	def __init__( self, capacity = 10) :
		self.capacity = capacity
		self.array = [None] * capacity
		self.front = 0
		self.rear = 0
```

- **공백 상태와 포화 상태를 검사하는 isEmpty()와 isFull() 연산**

공백 상태는 front == rear인 경우입니다. 이들이 0이 되어야 할 필요는 없습니다. 단지 front와 rear가 같은 곳을 가리키기만 하면 큐는 공백 상태 입니다.


오류 상태는 front == rear인 상태로 공백 상태와 구분이 되지 않습니다. 따라서 원형 큐에서는 보통 하나의 자리를 비워두는 전략을 사용합니다. 즉, (b)와 같이 **front가 near의 바로 다음에 있으면 포화 상태**라고 정의합니다. 시계 방향의 회전까지 고려하면 front == (rear+1)% capacity가 포화 상태 입니다.

```python
	def isEmpty(self):
		return self.front == self.rear
	
	def isFull(self):
		return self.front == (self.rear+1)%self.capacity
```

- **새로운 요소 e를 삽입하는 enqueue(e) 연산**

후단 rear를 먼저 시계 방향으로 한칸 회전시키고, 그 위치에 새로운 요소 e를 복사하면 됩니다. 물론 삽입은 포화 상태가 아니어야 가능합니다.

```python
	def enqueue( self, item ):
		if not self.isFull():
			self.rear = (self.rear + 1) % self.capacity
			self.array[self.rear] = item
		else : pass
```

- **맨 앞의 요소를 삭제하는 dequeue() 연산**

삭제는 큐에 요소가 남아 있어야 가능합니다. 큐가 공백이 아니면 먼저 front를 시계 방향으로 한칸 회전시키고 그 위치의 요소를 반환하면 됩니다.

```python
	def dequeue( self ):
		is not self.isEmpty():
			self.front = (self.front + 1) % self.capacity
			return self.array[self.ront]
		else: pass
```

- **맨 앞의 요소를 들여다보는 peek() 연산**

front를 시계 방향으로 한칸 회전 시킨 위치를 요소를 반환하면 됩니다.

```python
	def peek(self):
		if not self.isEmpty():
			return self.array[(self.front + 1)%self.capacity]
		else: pass
```

- **전체 요소의 수를 구하는 size() 연산**

만약 rear-front가 음수라면 추가로 용량을 더해 양수로 만들어야 합니다. 따라서 원형 큐의 전체 요소의 수는 (rear-front+capacity)%capacity가 됩니다. 그림과 같이 전체 요소의 수는 (0-2+5)%5=3 입니다.


```python
	def size( self ):
		return (self.rear - self.front + self.capacity) % self.capacity
```

- **큐의 내용을 출력하는 display() 연산**

원형 큐에 저장된 모든 요소를 큐에 들어온 순서대로 출력하는 연산을 구현해 보겠습니다. 맨 앞 요소는 그림과 같이 front의 다음 위치(front+1)에 있으며, 출력할 요소의 수는 size()개 입니다. 물론 인덱스는 시계 방향으로 회전되어야 하므로 나머지 연산을 적용해야 합니다.


```python
	def display(self, msg):
		print(msg, end='= [')
		for i in range(self.front+1, self.front+1+self.size()):
			print(self.array[i%self.capacity], end= ' ')
		print(']')
```

### 큐의 활용

원형 큐의 동작을 확인하기 위해 간단한 프로그램을 만들어 보겠습니다. 무작위로 발생한 정수(0~99)를 큐가 꽉 찰 때 까지 삽입한 후, 다시 모든 숫자를 꺼내 출력하는 것 입니다.

```python
import random
	q = ArrayQueue(8)
	
	q.display("초기 상태")
	while not q.isFull():
		q.enqueue(random.randint(0,100))
	
	q.display("포화 상태")
	
	print("삭제 순서: ", end='')
	while not q.isEmpty():
		print(q.dequeue(), end=' ')
	print()
```

### 원형 큐를 링 버퍼로 사용하기

원형 큐는 오래된 자료를 버리고 항상 최근의 자료를 유지하는 용도로 사용할 수 있습니다. 예를 들어, 그림과 같이 최대 7개의 요소를 저장할 수 있는 원형 큐에 7개 이상의 자료들이 연속적으로 입력되었을 때 **가장 최근에 들어온 7개만 저장되도록 하고 오래된 데이터는 버리는 것**입니다. 이러한 원형 큐를 **링 버퍼(ring buffer)**라고 합니다.


포화 상태에서 삽입연산을 추가로 수행하면 기존의 원형 큐에서는 오버플로 오류가 발생하고 삽입은 실패합니다. 이에 비해 링 버퍼에서는 원형 큐의 enqueue를 약간 수정하여 포화 상태와 상관없이 항상 삽입할 수 있도록 합니다. 물론 이 과정에서 가장 오래된 요소가 버려집니다. (c)와 같이 포화 상태가 되더라도 무조건 다음 위치에 데이터(7)를 일단 삽입합니다. 삽입이 끝나면 front와 rear가 같아지는 오류 상태가 되는데, 이때 front를 하나 증가 시킵니다. 즉, **가장 오래된 데이터를 삭제해서 큐를 계속 포화 상태로 유지**하는 것 입니다.

```python
	def enqueue2( self, item ):
		self.rear = (self.rear + 1) % self.capacity
		self.array[self.rear] = item
		if self.isEmpty():
			self.front = (self.front + 1) % self.capacity

q = ArrayQueue(8)

q.display("초기 상태")
for i in range(6):
	q.enqueue2(i)
q.display("삽입 0-5")

q.enqueue2(6)
q.enqueue2(7)
q.display("삽입 6,7")

q.enqueue2(8)
q.enqueue2(9)
q.display("삽입 8,9")

q.dequeue()
q.dequeue()
q.display("삭제 x2")
```
